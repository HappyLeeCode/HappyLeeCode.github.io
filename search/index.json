[{"content":" ✍ 写在前面 几经周折，多次迭代。我的 “小破站” 才成为了今天，你所看到的模样！\n而今，当我再次回首，这种感觉真的很奇妙，实有——“沉舟侧畔千帆过，病树前头万木春” 之感。\n特别感谢：\nAding阿定，对我网站建设中的答疑解惑；\nFomalhaut，所编写的系列关于博客网站搭建的教程；\n我的大学同学：谢同学、王同学等在网站体验后的反馈与建议；\n以及，GitHub上Dmego、imsyy两位佬的开源项目。\n除此之外，本网站用到的Stack主题，与Hugo、GitHub、Netlify、Twikoo等提供的服务支持\n我在此，一并致以最诚挚的感谢！🌹\n那么现在，来看看网站都有哪些具体的 新特色 吧！\n📆 时间轴 2022年11月3日 基于Hexo框架上线了第一版博客网站 —— 传送门\n2022年12月 网站实现了Github和Gitee 双平台部署\n2023年3月 网站使用了Butterfly主题风格 —— 传送门\n2023年4月 创建了“电路实验”板块，并由此陆续上传课程实验供同学们参考\n2023年5月 五一期间开始对网站结构，进行了较大的调整：\n申请个人域名 —— happylee.cn 新增个人主页 —— 传送门 新增上网导航页 —— 传送门 新建博客专用图床 部署到Vercel，进一步优化网站访问速度 新增了Twikoo评论系统（支持Twikoo/Livere双评论系统） 2023年6月 开始自学C++，并上传有关学习笔记（黑马程序员课程讲义）\n2023年10月 再次对网站架构和内容，进行了较大的整改：\n更换博客生成框架：Hexo → Hugo 更换博客主题：Butterfly → Stack 更换部署环境：Vercel → Netlify 整合网站现有内容，形成“项目”板块 优化了相关设置，增强网站响应体验 📣 大事件（不定期持续更新~） 🆕自定义域名 域名，作为每一个网站的标识，就像我们一个人的名字一样，其重要性可谓是不言而喻的！\n于是这次，我在腾讯云上注册了happylee.cn这个域名\n上面这个顶级域名，我分配给了新建的个人主页\n给博客网站分配的是blog.happylee.cn这个二级域名\n由于一些原因，blog.happylee.cn这个域名不得不被暂停使用\n现在，happylee.cn这个顶级域名，分配给了博客网站使用\n原来的个人主页，重新分配了home.happylee.cn的域名\n这里我也简述一下自己搭建博客的历程：\n原来本网站是利用GitHub上的pages服务，将本地借助hexo生成的博客网页文件，部署上传到GitHub后，这个pages服务会自动识别这些文件并生成一个xxxx.github.io的链接(其中xxxx为GitHub用户名)。那么之后，我们就可以通过这个xxxx.github.io的链接在浏览器中访问这个博客网站了。\n关于具体搭建博客步骤，感兴趣的同学可以去浏览我的第一篇博客文章\n总而言之，去年我就是按这个方法，搭建了最开始的博客网站，就是下面这个：（点我跳转）\n当时技术有限，像什么评论系统，以及一些小的页面都不会弄，而且这个网站还有很多地方没有改过来 最重要的是——受国内对GitHub的限制，访问这个网站很不稳定，打开网站的速度也很慢 然后，由于学业，我的博客网站搭建也就告一段落了。。。。。\n不过，今年我又重新开始了博客网站的建设。毕竟搭博客还只是小事，在我看来，最重要的是学一些技术，做一些小项目，然后写文章去记录这些历程，其次才是放在网站上。\n于是，就有了下面这个博客网站了（这次部署到了“国内的GitHub”——Gitee上，并且采用butterfly这个主题）：\n同时，我将这学期写的电路实验报告放在了上面，供同学们参考\n这次搭建博客的原理和最开始放到GitHub上是一样的，由于Gitee服务器在国内，所以这次的博客访问更加稳定速度，也更快了。\n但是由于写文章时，难免是要配一些图片的。考虑到网站本地图片加载速度慢的问题，搭建一个专门为博客使用的图床 - (百度百科)是大势所趋。\n然而，原来采用picgo+vika搭建图床的方案现在行不通了。这次vika图床的失效，综合各种因素，也促使我重新考虑将网站又部署回到了GitHub上。同时，也是借助这次机会，我注册了自己的域名，并也是利用GitHub搭建了自己的图床，网站做成了现在这个样子。\n🆕新增个人主页 既然，有了自己的域名，那么~~顶级域名happylee.cn~~肯定是用来给自己的个人主页啦——Lee\u0026rsquo;s Home\n上面这个页面，采用了GitHub上的一个开源项目——https://github.com/dmego/home.github.io\n具体仓库为：\n🆕新增上网导航页 仔细的你，肯定发现我的个人主页中，有一个导航这个按钮吧！\n点击它，就会打开这么一个页面了：\n实现这个功能的页面，也是来源于GitHub上的一个开源项目——https://github.com/imsyy/Snavigation\n写到这里，我不禁得好好表示对上面两位大佬的感谢，毕竟我纯纯是在白嫖！！！\n🆕新建了博客的专用图床 这部分我觉得没啥好说的：\n主要是跟着这个教程：https://www.fomal.cc/posts/d7fb1ba1.html\n然后就有了下面一个我的图床，其实就是一个GitHub仓库，把图片上传到这里面，就可以拥有图片的链接了。\n（重要的是学习教程中一些有关添加CDN，以及在Vercel上部署等技巧，使得图床链接访问更快、更稳定）\n🆕部署到Vercel，进一步优化网站访问速度 Vercel的官网地址：https://vercel.com/ Vercel 是一个网站托管服务平台，开发者可以将自己的网络应用部署、托管在平台上运行。\nVercel类似于github page，但远比github page强大，速度也快得多得多，而且将Github授权给vercel后，可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了。\n更加专业一点地说，vercel 的定位一个是零配置的静态资源和无服务器云计算（serverless) 部署平台，vercel 的 serverless function 背后用的其实是 AWS 的 lambda，因此可以部署在全球多个地区的 AWS 服务器，利用 vercel 的 Edge network ，可以实现让访客访问到离自己最近的内容，提高网站速度。\n上面就是我这次网站的所有项目在Vercel上的部署，每个项目我都解析并分配到了一个各自的域名，于是现在就可以更加流畅快速地通过这些域名访问我的个人网站、博客、导航页、图床等。\n🆕新增了Twikoo评论系统（现支持Twikoo/Livere双评论系统） 原来我的博客网站只支持livere（来必力）评论系统，读者在评论时需要登录社交帐号：\n然而，在使用过程中我发现：尽管我设置了邮箱提醒系统，但是当别人在博客网站上评论时，我却还是收不到评论提醒，就很容易错过一些消息。\n于是，这次我新增了twikoo这个新的评论系统，因此现在就支持这两种评论模式，并且twikoo提供的评论系统不需要登录社交帐号，只需要填写一个自己给定的昵称和邮箱就可以评论：\n现在默认使用的是twikoo，想要用livere登录社交帐号评论时，只需要点击上图方框中那个按钮切换就行\ntwikoo的好处就在于：它能够确切地通过邮箱，告诉评论人和博主有关这条评论的回复消息。\n如果你也想采用twikoo评论系统，请查看这篇文档——https://twikoo.js.org/quick-start.html\n😉 最后啦 至此，本篇文章就结束了。码字不易，还请多多支持本站，欢迎您的后续关注！\n另外，如果您有什么问题或者发现了网站中的一些错误，以及对网站的一些建议，都欢迎您在下方评论区留言和我交流、讨论！\n","date":"0001-01-01T00:00:00Z","image":"https://www.happylee.cn/post/about-blog/top.png","permalink":"https://www.happylee.cn/post/about-blog/","title":"📌置顶：关于本站"},{"content":" 正文 弃我去者，昨日之日不可留；乱我心者，今日之日多烦忧。\n——李白《宣州谢朓楼饯别校书叔云》\n不知不觉间，大学本科的四年时光只剩最后一年了。回望三年前的这个时候，自己才刚填完高考志愿，没日没夜地等待着系统的最终录取结果，而惴惴不安：\n一方面，对那些希望渺茫的名校专项计划，而仍旧抱有最后一丝的幻想；一方面，对那早已成定局的高考成绩，虽于外人差强人意，可自己却十分不甘而不断地悔恨终日；一方面，对即将到来的大学生活，虽早就充满期许，却也无限迷茫，也更害怕自己最后惨遭调剂，四年里读着一个冷门的专业，做着自己不喜欢的事情\u0026hellip;\u0026hellip;\n所以说，人性总归是贪婪的。换句话说，即使我当初按正常发挥，考下一个211的分数，我或许仍旧会为自己怎么不再多考一点分而上个985而苦恼。当然，这也说明：人啊，总归是积极的，而不断地去追求更好的事物。\n得到一切都尘埃落定时，是一个晚上，在不知道已经刷新了多少次系统后，它最终告诉我被省内一所比较好的一本院校给录取了。\n这对于我来说也算是个不错的消息，毕竟这所学校与自己的高考分数较为匹配，至少算是不存在“亏分”吧！但不幸的是，我还是未能逃脱被调剂的命运。因为我“求稳”，因此录取的是我填在靠前的“国家专项计划”，这个计划其实就是哪个专业差人就往那里面塞人。从后面上看，如果我当初将“机械类”啊、“数学类”啊或者“车辆类”啊，这些较为正常和一般的专业填在前面，或许就不用被调剂到“土木类”这个我很难评价的专业了（当时，土木工程虽然出现颓势，但还算是工科里面的传统好专业了，可我真对这个专业没有一点兴趣）\n所以说，就有我后面的转专业了。这个事情我和很多同学也都讲过很多遍了：大一学期末填了表，在机械、数学、信息和计算机这几个学院中，由于当时的转专业要求和个人实际情况，再加上家里面爸爸一直推荐“电气自动化”，就选择了转去信息学院。接着在几百人中，经过高数笔试和面试的反复筛选，最终成为了那幸运的三十个人中的一个吧。\n后来大一下的专业分流，我却是没有去选择信息学院里的“电气自动化”这个方向，而是想着自己要往软件上发展，就选择了“电子信息工程”这个方向。\n实迷途其未远，觉今是而昨非。\n——陶渊明《归去来兮辞》\n时至今日，我也算是个“老电信人”吧！大学读到今天，也逐渐明白，自己读什么专业实际上影响不大。一方面，大学本科里其实学校教不了什么，你真的热爱一项东西，还得靠你自己去摸索和学习；另一方面，的的确确相当大的一部分人未来就业干什么，与他们当初读的专业没有太大的关系。而且我现在也慢慢感受到，要找到一份自己想要的工作，并不是由你的专业而定，而是还有别的、其它的很多因素\u0026hellip;\u0026hellip;\n不想扯那么远了，退回到正题吧。前面算是对自己“过去”有一个小的总结吧，老实说我早就想对自己这么总结一下。或者说，像别人写博客那样搞一个“年度总结”。但我这个人总是心里面想着一件事情，而迟迟拖着不肯行动。\n当然，还有就是自己有个顾虑，我怕自己万一在这种文章里，后面又豪情壮志地、情不自禁地开始立一些“flag”，而我总是立什么flag，就做不到什么，反而还徒增焦虑了。于是索性就不立了，如此感觉这种年度总结与未来展望的文章也没必要写了。而且今年我也在忙着考研，时间也很是紧迫，一直也没什么时间去写一个长篇大论出来！\n看到这里，你或许会惊讶：“咦，你这不还是写了这么一大段辣鸡文章了么？”\n是啊，写到这里，从凌晨一点四十开始起，已经到三点多了，距离今年下半年的全国硕士研究生统一招生考试还有162天5时0分0秒（2024年7月12日3:30）\u0026hellip;\u0026hellip;\n最近啊，我的状态越来越差了，我一直想着自己能够进入暑假了，可以沉下心来准备考研，但是我做不到啊！就是无法进入学习状态，而且我还有好多科目的很多内容还没开始！周边的、网上的一堆人比我学得早、学得多、学得快，我是真的着急，又焦虑！暑假我选择了留校，而室友都回去了，就剩我一个人。我也不喜欢去图书馆里碰到熟人，主要是熟人都基本上一个专业，我真怕再看到他们的进度远远领先我了。有时，想发个消息给玩的好的朋友，可大家都忙，或者也在考研，有也觉得自己有点晦气，于是也就不想打扰他们。\n干耗着，问题没有解决，学也学不进去，时间在我眼前走着，一天过去了，两天过去，一周过去了，进度还是很落后。\n其实我真的很不想去备考这些考研数学啊，英语啊什么的。真的太理论很枯燥。而且说实在的，比起这些，我真正享受的还是诸如编程啊单片机啊那些，你解决一个个小问题后，最终设计得到一个成品的满足感与成就感！\n但是，我也没有办法，一方面自己大学里面学的不深，而且学校背景一般般，真的很难让我去未来从事我想要的那些工作；另一方面，也算是自己可笑的名校梦吧！真的是意难平啊，一直也很难放过自己。其实，到大学了我自己仍是在学习上努力要求。至少绩点也还算可以，尽管进不了那残酷的保研名额中，因为我有些科目成绩很低（如60~70这样飘飘过的样子）但我觉得自己高数100，概率100，专业课多数都是90+，很多甚至是95啊、98啊这样的高分，这至少说明了我真的有在努力学习，想着后面去提升自己。\n现在时不时爱刷着B站，看那过去的革命者事迹，他们在当时旧中国环境下，依旧坚信前途光明的那种乐观主义，我真的渴望拥有。我觉得这种意志品质，远远比那昂贵的考研辅导资料和专业人员辅导重要。\n后记 沉舟侧畔千帆过，病树前头万木春\n——刘禹锡《酬乐天扬州初逢席上见赠》\n记得刚开始上土木专业的认知课时，提不上一点兴趣，但如今也算幸运转专业成功了；记得以前期末，有时会担心一些科目挂了，但如今望着成绩也还行，算是走过来了；记得升大三时自己很多东西不会，就那半个学期，我自学了C++并考取了二级证书，自学QT写了第一款自己的小软件，还参加了数学建模、蓝桥杯等竞赛，取得了一些虽不高但还算可以的成绩\u0026hellip;\u0026hellip;\n今天又整理了GitHub的仓库，发现自己不知不觉间，也算是做了很多小东西的；而且看看搞这些网站，不知不觉搞了快到两年了（第一次是大二上开始弄的，而现在快要大四了），也因此在网上认识了很多志同道合的朋友。\n前两天，听考研英语静姐说了一句话：“人生没有白走的路，你所走的每一步都算数。”\n我不知道自己最后能不能走到我想要到达的终点，而且从现在来看，这也仿佛并不重要了！那么真正的，是我的确要坚持把它给走下去\u0026hellip;\u0026hellip;\n（感谢你能看到这里，也不知道这篇文章最后哪些人能看到。写到这里我也不想再去修改这篇文章了，哪怕有错误之处，当然这篇文章理应要配一些图片，而这些就都是后话了。我想还是要把时间花在我现在该做的事情上，至少此刻我得去睡一觉了！）\n","date":"2024-07-12T01:40:21+08:00","image":"https://www.happylee.cn/post/life-dream-2024/top.png","permalink":"https://www.happylee.cn/post/life-dream-2024/","title":"过去、现在、未来：在迷茫中起舞，为理想而高歌"},{"content":"LCP_MNIST：基于CNN+Adam的手写数字识别项目 写在前面：\n🚩 本项目为电子信息工程专业生产实习的小组结课作业 🏆 本项目由LCP速通小组创立和维护，并最终荣获了“优秀项目奖” 🤝 关于本项目的相关代码和训练数据集，已在GitHub上开源，仅作学习交流用途 🔞 严禁直接抄袭本项目、复制粘贴改名等学术不端行为 项目简介：\nMNIST是一个非常经典的手写数字数据集，由美国国家标准与技术研究所（NIST）在20世纪80年代整理和标注。这个数据集包含了一系列0到9的手写数字图像，用于机器学习中的图像分类任务。MNIST数据集被广泛应用于训练和验证机器学习模型的性能。\n在本次生产实习项目作业中，我们LCP速通小组根据老师提供的一个最基础的基于MNIST数据集的神经网络训练框架，对里面给定的三个基本模型进行优化修改和训练，并对测试的结果进行可视化，以及最后制作了我们自己的数据集。\n团队介绍：\n🤗 为什么叫“LCP速通小组”？\n​ ”LCP“英文全称为：Lectures on Communication Principles ，即“通信原理教程”。\n因此，整个小组名其实就是”通信原理速通小组“的意思。\n🤡 这源于进行生产实习期间，我们专业当时正好有一门名叫《通信原理》的课程要结课考试。\n获取项目 💌 项目地址：点我跳转到GitHub仓库\n​\t（或者，使用以下命令拷贝到本地）\n1 git clone https://github.com/HappyLeeCode/LCP_MNIST.git 环境配置 ​\t本项目所使用的有关软件和外部依赖库版本为：\nPyCharm Community Edition 2024.1.3 Python 3.11.7 torchvision\ntensorboard opencv-python matplotlib~=3.8.0 pillow~=10.2.0\n在启动虚拟环境下使用pip命令安装opencv­—python： 1 pip install opencv-python -i \u0026lt;https://pypi.tuna.tsinghua.edu.cn/simple\u0026gt; 安装pytorch: 1 pip install torch torchvision torchaudio -i https://pypi.tuna.tsinghua.edu.cn/simple 安装Tensorboard:\n在本次项目中我们使用tensordboard工具对训练过程中的训练损失和验证损失进行记录并以曲线的形式呈现。\n1 pip install tensorboard 项目结构 项目结构图 data文件夹是保存MNIST官方数据集的文件夹，无需改动\ndocs文件夹是保存我们的项目说明文档和相关图片，无需改动\nlogs文件夹是保存我们已经训练过的不同模型的训练损失和验证损失可视化结果（基于Tensorboard），不需改动\nmodels文件夹是用来保存卷积神经网络模型代码，其中LeNet.py，ney.py，vgg16.py是老师提供的初始模型，其中vgg16.py中的vgg模型和LeNet.py中的Module模型已被我们调试好，可以运行；\nour_dataset文件夹是用来保存我们自己制作的数据集，包含自己手写数字图片，与标签文件等\ntools文件夹存放有用于图片处理的process.py，训练train.py，以及用于评估的evaluate.py程序等\n模型建立与优化 ​\t关于MNIST的基础卷积神经网络是这样设计的，\n第一层是一个卷积层，输入通道是1，输出通道是32，卷积核大小是3×3。输入维度是1×28×28，输出维度是32×28×28。\n第二层是一个下采样层，采样核大小是2×2，输入维度是32×28×28，输出维度是32×14×14。\n第三层是一个卷积层，输入通道是32，输出通道是64，卷积核大小是3×3。输入维度是32×14×14，输出维度是64×14×14。\n第四层是一个下采样层，采样核大小是2×2，输入维度是64×14×14，输出维度是64×7×7。\n第五层是展平层，张量维度为64×7×7。\n第六层是一个全连接层，输出神经元个数为128个。\n第七层是一个全连接层，输出神经元个数为10个。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import torch.nn as nn import torch.nn.functional as F class CNN(nn.Module): def __init__(self): super(CNN, self).__init__() self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1) self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1) self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0) self.fc1 = nn.Linear(128 * 7 * 7, 128) self.fc2 = nn.Linear(128, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 128 * 7 * 7) x = F.relu(self.fc1(x)) x = self.fc2(x) ​\t在基础的卷积神经网络CNN下我们进行了修改，给出了一个目前调试得最好的CNN模型，其设计如下：\n第一层是一个卷积层，输入通道是1，输出通道是32，卷积核大小是3×3。输入维度是1×28×28，输出维度是32×28×28。\n第二层是一个下采样层，采样核大小是2×2，输入维度是32×28×28，输出维度是32×14×14。\n第三层是一个卷积层，输入通道是32，输出通道是64，卷积核大小是3×3。输入维度是32×14×14，输出维度是64×14×14。\n第四层是一个下采样层，采样核大小是2×2，输入维度是64×14×14，输出维度是64×7×7。\n第五层是一个卷积层，输入通道是64，输出通道是128，卷积核大小是3×3。输入维度是64×7×7，输出维度是128×7×7。\n第六层是展平层，张量维度为128×7×7。\n第七层是一个全连接层，输出神经元个数为128个。\n第八层是一个全连接层，输出神经元个数为256个。\n第九层是一个全连接层，输出神经元个数为10个。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import torch.nn as nn import torch.nn.functional as F class CNN(nn.Module): def __init__(self): super(CNN, self).__init__() self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1) self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1) self.conv3 = nn.Conv2d(64, 128, kernel_size=3, padding=1) self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0) self.fc1 = nn.Linear(128 * 7 * 7, 128) self.fc2 = nn.Linear(128, 256) self.fc3 = nn.Linear(256, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = (F.relu(self.conv3(x))) x = x.view(-1, 128 * 7 * 7) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) ​\t此外我们还基于CNN调试了其他三个模型，但效果不如上文调试出的最好模型，下面做出简要介绍:\n第一个：在基础模型上往欠拟合方向进行改动：在第一个全连接层后加入dropout层进行正则化\n第二个：在最佳模型上往欠拟合方向进行改动：删除第三个卷积层\n第三个：在最佳模型上往过拟合方向进行改动：将卷积核大小改为5 * 5\n模型训练 ​\t运行tools文件夹下的train.py文件，会分别选择对应的神经网络进行训练。训练后生成.pth保存训练好的模型权重，以及在logs文件夹的fit下面生成一个保存训练过程中损失数据的文件。\n训练过程可视化 ​\t利用tensorboard，使用时可在pycharm的终端下使用命令：\n1 tensorboard--logdir=\u0026#34;(路径替换为自己的路径)\u0026#34; ​\t这会生成一个端口，进入端口即可查看记录数据\n模型测试 在our_dataset/test_data文件夹下的10个文件夹下放入对应的手写数字图片，图片长和宽随意，注意图片要是黑底白字的。\n如果要测试训练好的CNN模型，请运行tools文件夹下的trained.py\n然后会在modules文件下生成一个mnist_cnn.pth，这样就保存好了训练好的模型。\n准确率参考：\n表1 不同模型在验证集上的最终准确率 model Accuracy epoch CNN(初始) 98.56% 2 VGG16(初始) 86.39% 2 Module(初始) 10.10% 2 表2 CNN模型在不同优化器测试后的最终准确率 trained-model 优化器 Accuracy epoch CNN SGD 93% 10 CNN Adam 97% 10 CNN(best) Adam 99% 10 训练结果可视化 ​\t运行tensorboard命令即可在浏览器中查看训练结果：\nCNN+Adam的训练损失曲线 CNN+Adam的验证损失曲线 制作自己的数据集 ​\tour_dataset文件夹下有三个文件夹，input、output、test_data。\ninput文件夹下，保存未处理的手写图片，比如保存数字1的手写图片，依次类推。\noutput文件夹下，保存从input文件夹中读取的所有图片，并经过了相关的处理。\ntest_data文件夹下，保存有我们处理好并经过标签分类好的测试图片。\n整个目录树如图所示：\n手写图片制作 ​\t打开windows画板，或者使用平板，写一些数字，然后用图片编辑软件裁剪图片，使得数字大概在裁剪图片的中心，然后在our_dataset/input文件夹下的10个文件夹下放入对应的手写数字图片。\n​\t我使用平板写的10个数字如下：\n图片批处理与标签生成 ​\t运行process.py，这样就会把input文件下的图片转换为黑底白字\n最终测试效果 ​\t运行tools下的evaluate.py。\n​\t话不多说，最终测评结果直接放图（自设置CNN+Adam）：\n","date":"2024-07-01T00:00:00Z","image":"https://www.happylee.cn/post/lcp-mnist/top.png","permalink":"https://www.happylee.cn/post/lcp-mnist/","title":"基于CNN+Adam的手写数字识别项目"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档 本部分的实验报告适用于电子信息工程专业，其他专业仅供参考 本实验中的程序运行环境为MATLAB R2022b，不同版本下的程序可能有所差异 严禁直接抄袭本报告、复制粘贴改名等学术不端行为 目录： 实验1 MATLAB 图像的点运算 实验2 空间域图像增强 实验3 图像的傅立叶变换 实验4 图像增强——频域滤波 实验5 数字图像的几何变换 实验6 形态学图像处理 实验7 图像分割 （实验报告中的程序代码，可点击这里查看）\n实验报告： Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档 严禁直接抄袭本报告、复制粘贴改名等学术不端行为！ ","date":"2024-06-30T00:00:00Z","image":"https://www.happylee.cn/post/digital-image-processing/matlab_img.png","permalink":"https://www.happylee.cn/post/digital-image-processing/","title":"数字图像处理实验报告"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档 本部分的实验报告适用于电子信息工程专业，其他专业仅供参考 本实验中的Linux运行环境为Ubuntu-22.04.3-desktop-amd64，不同版本下的程序可能有所差异 严禁直接抄袭本报告、复制粘贴改名等学术不端行为 目录： 实验一：熟悉系统命令 实验二：运用C语言函数实现操作系统中文件的读写操作 实验三：熟悉操作系统中进程通信的实例——管道的建立 思考题：利用系统调用实现shell功能 个人小结 实验报告： Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档 严禁直接抄袭本报告、复制粘贴改名等学术不端行为！ ","date":"2023-12-20T00:00:00Z","image":"https://www.happylee.cn/post/linuxos-course/linux.jpeg","permalink":"https://www.happylee.cn/post/linuxos-course/","title":"Linux操作系统实验"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档 本部分的实验报告适用于电子信息工程专业，其他专业仅供参考 本实验中的程序运行环境为MATLAB R2022b，不同版本下的程序可能有所差异 严禁直接抄袭本报告、复制粘贴改名等学术不端行为 目录： 实验一 信号系统及系统响应 实验二 用FFT作谱分析 实验三 模拟滤波器及IIR数字滤波器的设计 实验四 基于窗函数的FIR数字滤波器的设计 （实验报告中的程序代码，可点击这里查看）\n实验报告： Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档 严禁直接抄袭本报告、复制粘贴改名等学术不端行为！ ","date":"2023-12-15T00:00:00Z","image":"https://www.happylee.cn/post/digital-signal-processing/matlab_img.png","permalink":"https://www.happylee.cn/post/digital-signal-processing/","title":"数字信号处理实验报告"},{"content":"C++核心编程 本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前 ​\t在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n​\t代码区：\n​\t存放 CPU 执行的机器指令\n​\t代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n​\t代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n​\t全局区：\n​\t全局变量和静态变量存放在此.\n​\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n​\t==该区域的数据在程序结束后由操作系统释放==.\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 int a = 10; int b = 10; //打印地址 cout \u0026lt;\u0026lt; \u0026#34;局部变量a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部变量b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_b \u0026lt;\u0026lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world1\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_b \u0026lt;\u0026lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 打印结果：\n总结：\nC++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后 ​\t栈区：\n​\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n​\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int * func() { int a = 10; return \u0026amp;a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​\t堆区：\n​\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n​\t在C++中主要利用new在堆区开辟内存\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n1.3 new操作符 ​\tC++中利用==new==操作符在堆区开辟数据\n​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n​\t语法： new 数据类型\n​\t利用new创建的数据，会返回该数据对应的类型的指针\n示例1： 基本语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //利用delete释放堆区数据 delete p; //cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //报错，释放的空间不可访问 system(\u0026#34;pause\u0026#34;); return 0; } 示例2：开辟数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //堆区开辟数组 int main() { int* arr = new int[10]; for (int i = 0; i \u0026lt; 10; i++) { arr[i] = i + 100; } for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } //释放数组 delete 后加 [] delete[] arr; system(\u0026#34;pause\u0026#34;); return 0; } 2 引用 2.1 引用的基本使用 **作用： **给变量起别名\n语法： 数据类型 \u0026amp;别名 = 原名\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int a = 10; int \u0026amp;b = a; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; b = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { int a = 10; int b = 20; //int \u0026amp;c; //错误，引用必须初始化 int \u0026amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.3 引用做函数参数 **作用：**函数传参时，可以利用引用的技术让形参修饰实参\n**优点：**可以简化指针修改实参\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //1. 值传递 void mySwap01(int a, int b) { int temp = a; a = b; b = temp; } //2. 地址传递 void mySwap02(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } //3. 引用传递 void mySwap03(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; mySwap01(a, b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; mySwap02(\u0026amp;a, \u0026amp;b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; mySwap03(a, b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n2.4 引用做函数返回值 作用：引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n用法：函数调用作为左值\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //返回局部变量引用 int\u0026amp; test01() { int a = 10; //局部变量 return a; } //返回静态变量引用 int\u0026amp; test02() { static int a = 20; return a; } int main() { //不能返回局部变量的引用 int\u0026amp; ref = test01(); cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; //如果函数做左值，那么必须返回引用 int\u0026amp; ref2 = test02(); cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; test02() = 1000; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​\n2.5 引用的本质 本质：引用的本质在c++内部实现是一个指针常量.\n讲解示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //发现是引用，转换为 int* const ref = \u0026amp;a; void func(int\u0026amp; ref){ ref = 100; // ref是引用，转换为*ref = 100 } int main(){ int a = 10; //自动转换为 int* const ref = \u0026amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int\u0026amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref:\u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; func(a); return 0; } 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //引用使用的场景，通常用来修饰形参 void showValue(const int\u0026amp; v) { //v += 10; cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } int main() { //int\u0026amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int\u0026amp; ref = temp; const int\u0026amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(\u0026#34;pause\u0026#34;); return 0; } 3 函数提高 3.1 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。\n语法： 返回值类型 函数名 （参数= 默认值）{}\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int func(int a, int b = 10, int c = 10) { return a + b + c; } //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) { return a + b; } int main() { cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; func(20, 20) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; func(100) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 3.2 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法： 返回值类型 函数名 (数据类型){}\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) { cout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(10,10); //占位参数必须填补 system(\u0026#34;pause\u0026#34;); return 0; } 3.3 函数重载 3.3.1 函数重载概述 **作用：**函数名可以相同，提高复用性\n函数重载满足条件：\n同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //函数重载需要函数都在同一个作用域下 void func() { cout \u0026lt;\u0026lt; \u0026#34;func 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;func (int a) 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(double a) { cout \u0026lt;\u0026lt; \u0026#34;func (double a)的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a ,double b) { cout \u0026lt;\u0026lt; \u0026#34;func (int a ,double b) 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(double a ,int b) { cout \u0026lt;\u0026lt; \u0026#34;func (double a ,int b)的调用！\u0026#34; \u0026lt;\u0026lt; endl; } //函数返回值不可以作为函数重载条件 //int func(double a, int b) //{ //\tcout \u0026lt;\u0026lt; \u0026#34;func (double a ,int b)的调用！\u0026#34; \u0026lt;\u0026lt; endl; //} int main() { func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(\u0026#34;pause\u0026#34;); return 0; } 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //函数重载注意事项 //1、引用作为重载条件 void func(int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func (int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; } void func(const int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func (const int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; } //2、函数重载碰到函数默认参数 void func2(int a, int b = 10) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b = 10) 调用\u0026#34; \u0026lt;\u0026lt; endl; } void func2(int a) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a) 调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(\u0026#34;pause\u0026#34;); return 0; } 4 类和对象 C++面向对象的三大特性为：==封装、继承、多态==\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n例如：\n​\t人可以作为对象，属性有姓名、年龄、身高、体重\u0026hellip;，行为有走、跑、跳、吃饭、唱歌\u0026hellip;\n​\t车也可以作为对象，属性有轮胎、方向盘、车灯\u0026hellip;,行为有载人、放音乐、放空调\u0026hellip;\n​\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n4.1 封装 4.1.1 封装的意义 封装是C++面向对象三大特性之一\n封装的意义：\n将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一：\n​\t在设计类的时候，属性和行为写在一起，表现事物\n语法： class 类名{ 访问权限： 属性 / 行为 };\n**示例1：**设计一个圆类，求圆的周长\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //圆周率 const double PI = 3.14; //1、封装的意义 //将属性和行为作为一个整体，用来表现生活中的事物 //封装一个圆类，求圆的周长 //class代表设计一个类，后面跟着的是类名 class Circle { public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() { //2 * pi * r //获取圆的周长 return 2 * PI * m_r; } }; int main() { //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout \u0026lt;\u0026lt; \u0026#34;圆的周长为： \u0026#34; \u0026lt;\u0026lt; c1.calculateZC() \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } **示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n示例2代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //学生类 class Student { public: void setName(string name) { m_name = name; } void setID(int id) { m_id = id; } void showStudent() { cout \u0026lt;\u0026lt; \u0026#34;name:\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; ID:\u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } public: string m_name; int m_id; }; int main() { Student stu; stu.setName(\u0026#34;德玛西亚\u0026#34;); stu.setID(250); stu.showStudent(); system(\u0026#34;pause\u0026#34;); return 0; } 封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\npublic 公共权限 protected 保护权限 private 私有权限 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //三种权限 //公共权限 public 类内可以访问 类外可以访问 //保护权限 protected 类内可以访问 类外不可以访问 //私有权限 private 类内可以访问 类外不可以访问 class Person { //姓名 公共权限 public: string m_Name; //汽车 保护权限 protected: string m_Car; //银行卡密码 私有权限 private: int m_Password; public: void func() { m_Name = \u0026#34;张三\u0026#34;; m_Car = \u0026#34;拖拉机\u0026#34;; m_Password = 123456; } }; int main() { Person p; p.m_Name = \u0026#34;李四\u0026#34;; //p.m_Car = \u0026#34;奔驰\u0026#34;; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(\u0026#34;pause\u0026#34;); return 0; } 4.1.2 struct和class区别 在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\nstruct 默认权限为公共 class 默认权限为私有 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class C1 { int m_A; //默认是私有权限 }; struct C2 { int m_A; //默认是公共权限 }; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(\u0026#34;pause\u0026#34;); return 0; } 4.1.3 成员属性设置为私有 **优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n**优点2：**对于写权限，我们可以检测数据的有效性\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Person { public: //姓名设置可读可写 void setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 int getAge() { return m_Age; } //设置年龄 void setAge(int age) { if (age \u0026lt; 0 || age \u0026gt; 150) { cout \u0026lt;\u0026lt; \u0026#34;你个老妖精!\u0026#34; \u0026lt;\u0026lt; endl; return; } m_Age = age; } //情人设置为只写 void setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人 }; int main() { Person p; //姓名设置 p.setName(\u0026#34;张三\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.getName() \u0026lt;\u0026lt; endl; //年龄设置 p.setAge(50); cout \u0026lt;\u0026lt; \u0026#34;年龄： \u0026#34; \u0026lt;\u0026lt; p.getAge() \u0026lt;\u0026lt; endl; //情人设置 p.setLover(\u0026#34;苍井\u0026#34;); //cout \u0026lt;\u0026lt; \u0026#34;情人： \u0026#34; \u0026lt;\u0026lt; p.m_Lover \u0026lt;\u0026lt; endl; //只写属性，不可以读取 system(\u0026#34;pause\u0026#34;); return 0; } 练习案例1：设计立方体类\n设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函数判断两个立方体是否相等。\n练习案例2：点和圆的关系\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n​\t一个对象或者变量没有初始状态，对其使用后果是未知\n​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nc++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名(){}\n构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名(){}\n析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Person { public: //构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { Person p; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.2 构造函数的分类及调用 两种分类方式：\n​\t按参数分为： 有参构造和无参构造\n​\t按类型分为： 普通构造和拷贝构造\n三种调用方式：\n​\t括号法\n​\t显示法\n​\t隐式转换法\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 //1、构造函数分类 // 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 // 按照类型分类分为 普通构造和拷贝构造 class Person { public: //无参（默认）构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 Person(int a) { age = a; cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person\u0026amp; p) { age = p.age; cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int age; }; //2、构造函数的调用 //调用无参构造函数 void test01() { Person p; //调用无参构造函数 } //调用有参的构造函数 void test02() { //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4); } int main() { test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.3 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况\n使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Person { public: Person() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = 0; } Person(int age) { cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = age; } Person(const Person\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = p.mAge; } //析构函数在释放内存之前调用 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int mAge; }; //1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() { Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作 } //2. 值传递的方式给函数参数传值 //相当于Person p1 = p; void doWork(Person p1) {} void test02() { Person p; //无参构造函数 doWork(p); } //3. 以值方式返回局部对象 Person doWork2() { Person p1; cout \u0026lt;\u0026lt; (int *)\u0026amp;p1 \u0026lt;\u0026lt; endl; return p1; } void test03() { Person p = doWork2(); cout \u0026lt;\u0026lt; (int *)\u0026amp;p \u0026lt;\u0026lt; endl; } int main() { //test01(); //test02(); test03(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.4 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Person { public: //无参（默认）构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 Person(int a) { age = a; cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 Person(const Person\u0026amp; p) { age = p.age; cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int age; }; void test01() { Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; } void test02() { //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.5 深拷贝与浅拷贝 深浅拷贝是面试经典问题，也是常见的一个坑\n浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Person { public: //无参（默认）构造函数 Person() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 Person(int age ,int height) { cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; m_age = age; m_height = new int(height); } //拷贝构造函数 Person(const Person\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); } //析构函数 ~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; if (m_height != NULL) { delete m_height; } } public: int m_age; int* m_height; }; void test01() { Person p1(18, 180); Person p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p1的年龄： \u0026#34; \u0026lt;\u0026lt; p1.m_age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; *p1.m_height \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p2的年龄： \u0026#34; \u0026lt;\u0026lt; p2.m_age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; *p2.m_height \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n4.2.6 初始化列表 作用：\nC++提供了初始化列表语法，用来初始化属性\n语法：构造函数()：属性1(值1),属性2（值2）... {}\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Person { public: ////传统方式初始化 //Person(int a, int b, int c) { //\tm_A = a; //\tm_B = b; //\tm_C = c; //} //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} void PrintPerson() { cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mB:\u0026#34; \u0026lt;\u0026lt; m_B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mC:\u0026#34; \u0026lt;\u0026lt; m_C \u0026lt;\u0026lt; endl; } private: int m_A; int m_B; int m_C; }; int main() { Person p(1, 2, 3); p.PrintPerson(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.7 类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n例如：\n1 2 3 4 5 class A {} class B { A a； } B类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Phone { public: Phone(string name) { m_PhoneName = name; cout \u0026lt;\u0026lt; \u0026#34;Phone构造\u0026#34; \u0026lt;\u0026lt; endl; } ~Phone() { cout \u0026lt;\u0026lt; \u0026#34;Phone析构\u0026#34; \u0026lt;\u0026lt; endl; } string m_PhoneName; }; class Person { public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) { cout \u0026lt;\u0026lt; \u0026#34;Person构造\u0026#34; \u0026lt;\u0026lt; endl; } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person析构\u0026#34; \u0026lt;\u0026lt; endl; } void playGame() { cout \u0026lt;\u0026lt; m_Name \u0026lt;\u0026lt; \u0026#34; 使用\u0026#34; \u0026lt;\u0026lt; m_Phone.m_PhoneName \u0026lt;\u0026lt; \u0026#34; 牌手机! \u0026#34; \u0026lt;\u0026lt; endl; } string m_Name; Phone m_Phone; }; void test01() { //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(\u0026#34;张三\u0026#34; , \u0026#34;苹果X\u0026#34;); p.playGame(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.2.8 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 **示例1 ：**静态成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Person { public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据 private: static int m_B; //静态成员变量也是有访问权限的 }; int Person::m_A = 10; int Person::m_B = 10; void test01() { //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout \u0026lt;\u0026lt; \u0026#34;p1.m_A = \u0026#34; \u0026lt;\u0026lt; p1.m_A \u0026lt;\u0026lt; endl; Person p2; p2.m_A = 200; cout \u0026lt;\u0026lt; \u0026#34;p1.m_A = \u0026#34; \u0026lt;\u0026lt; p1.m_A \u0026lt;\u0026lt; endl; //共享同一份数据 cout \u0026lt;\u0026lt; \u0026#34;p2.m_A = \u0026#34; \u0026lt;\u0026lt; p2.m_A \u0026lt;\u0026lt; endl; //2、通过类名 cout \u0026lt;\u0026lt; \u0026#34;m_A = \u0026#34; \u0026lt;\u0026lt; Person::m_A \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;m_B = \u0026#34; \u0026lt;\u0026lt; Person::m_B \u0026lt;\u0026lt; endl; //私有权限访问不到 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **示例2：**静态成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Person { public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() { cout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 } static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() { cout \u0026lt;\u0026lt; \u0026#34;func2调用\u0026#34; \u0026lt;\u0026lt; endl; } }; int Person::m_A = 10; void test01() { //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3 C++对象模型和this指针 4.3.1 成员变量和成员函数分开存储 在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Person { public: Person() { mA = 0; } //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() { cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mA \u0026lt;\u0026lt; endl; } //静态成员函数也不占对象空间 static void sfunc() { } }; int main() { cout \u0026lt;\u0026lt; sizeof(Person) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 4.3.2 this指针概念 通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Person { public: Person(int age) { //1、当形参和成员变量同名时，可用this指针来区分 this-\u0026gt;age = age; } Person\u0026amp; PersonAddPerson(Person p) { this-\u0026gt;age += p.age; //返回对象本身 return *this; } int age; }; void test01() { Person p1(10); cout \u0026lt;\u0026lt; \u0026#34;p1.age = \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.3 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //空指针访问成员函数 class Person { public: void ShowClassName() { cout \u0026lt;\u0026lt; \u0026#34;我是Person类!\u0026#34; \u0026lt;\u0026lt; endl; } void ShowPerson() { if (this == NULL) { return; } cout \u0026lt;\u0026lt; mAge \u0026lt;\u0026lt; endl; } public: int mAge; }; void test01() { Person * p = NULL; p-\u0026gt;ShowClassName(); //空指针，可以调用成员函数 p-\u0026gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.3.4 const修饰成员函数 常函数：\n成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象：\n声明对象前加const称该对象为常对象 常对象只能调用常函数 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Person { public: Person() { m_A = 0; m_B = 0; } //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const { //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-\u0026gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-\u0026gt;m_B = 100; } void MyFunc() const { //mA = 10000; } public: int m_A; mutable int m_B; //可修改 可变的 }; //const修饰对象 常对象 void test01() { const Person person; //常量对象 cout \u0026lt;\u0026lt; person.m_A \u0026lt;\u0026lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.4 友元 生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为 ==friend==\n友元的三种实现\n全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Building { //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building); public: Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } public: string m_SittingRoom; //客厅 private: string m_BedRoom; //卧室 }; void goodGay(Building * building) { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { Building b; goodGay(\u0026amp;b); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.4.2 类做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Building; class goodGay { public: goodGay(); void visit(); private: Building *building; }; class Building { //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay; public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.4.3 成员函数做友元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Building; class goodGay { public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building; }; class Building { //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void goodGay::visit2() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n4.5.1 加号运算符重载 作用：实现两个自定义数据类型相加的运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Person { public: Person() {}; Person(int a, int b) { this-\u0026gt;m_A = a; this-\u0026gt;m_B = b; } //成员函数实现 + 号运算符重载 Person operator+(const Person\u0026amp; p) { Person temp; temp.m_A = this-\u0026gt;m_A + p.m_A; temp.m_B = this-\u0026gt;m_B + p.m_B; return temp; } public: int m_A; int m_B; }; //全局函数实现 + 号运算符重载 //Person operator+(const Person\u0026amp; p1, const Person\u0026amp; p2) { //\tPerson temp(0, 0); //\ttemp.m_A = p1.m_A + p2.m_A; //\ttemp.m_B = p1.m_B + p2.m_B; //\treturn temp; //} //运算符重载 可以发生函数重载 Person operator+(const Person\u0026amp; p2, int val) { Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp; } void test() { Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p3.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p3.m_B \u0026lt;\u0026lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p4.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p4.m_B \u0026lt;\u0026lt; endl; } int main() { test(); system(\u0026#34;pause\u0026#34;); return 0; } 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n总结2：不要滥用运算符重载\n4.5.2 左移运算符重载 作用：可以输出自定义数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Person { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p); public: Person(int a, int b) { this-\u0026gt;m_A = a; this-\u0026gt;m_B = b; } //成员函数 实现不了 p \u0026lt;\u0026lt; cout 不是我们想要的效果 //void operator\u0026lt;\u0026lt;(Person\u0026amp; p){ //} private: int m_A; int m_B; }; //全局函数实现左移重载 //ostream对象只能有一个 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p) { out \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; p.m_B; return out; } void test() { Person p1(10, 20); cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //链式编程 } int main() { test(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n4.5.3 递增运算符重载 作用： 通过重载递增运算符，实现自己的整型数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class MyInteger { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint); public: MyInteger() { m_Num = 0; } //前置++ MyInteger\u0026amp; operator++() { //先++ m_Num++; //再返回 return *this; } //后置++ MyInteger operator++(int) { //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; } private: int m_Num; }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint) { out \u0026lt;\u0026lt; myint.m_Num; return out; } //前置++ 先++ 再返回 void test01() { MyInteger myInt; cout \u0026lt;\u0026lt; ++myInt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; } //后置++ 先返回 再++ void test02() { MyInteger myInt; cout \u0026lt;\u0026lt; myInt++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; } int main() { test01(); //test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 前置递增返回引用，后置递增返回值\n4.5.4 赋值运算符重载 c++编译器至少给一个类添加4个函数\n默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class Person { public: Person(int age) { //将年龄数据开辟到堆区 m_Age = new int(age); } //重载赋值运算符 Person\u0026amp; operator=(Person \u0026amp;p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //年龄的指针 int *m_Age; }; void test01() { Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout \u0026lt;\u0026lt; \u0026#34;p1的年龄为：\u0026#34; \u0026lt;\u0026lt; *p1.m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为：\u0026#34; \u0026lt;\u0026lt; *p2.m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3的年龄为：\u0026#34; \u0026lt;\u0026lt; *p3.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 4.5.5 关系运算符重载 **作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; }; bool operator==(Person \u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } bool operator!=(Person \u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return false; } else { return true; } } string m_Name; int m_Age; }; void test01() { //int a = 0; //int b = 0; Person a(\u0026#34;孙悟空\u0026#34;, 18); Person b(\u0026#34;孙悟空\u0026#34;, 18); if (a == b) { cout \u0026lt;\u0026lt; \u0026#34;a和b相等\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a和b不相等\u0026#34; \u0026lt;\u0026lt; endl; } if (a != b) { cout \u0026lt;\u0026lt; \u0026#34;a和b不相等\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a和b相等\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MyPrint { public: void operator()(string text) { cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; } }; void test01() { //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(\u0026#34;hello world\u0026#34;); } class MyAdd { public: int operator()(int v1, int v2) { return v1 + v2; } }; void test02() { MyAdd add; int ret = add(10, 10); cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; //匿名对象调用 cout \u0026lt;\u0026lt; \u0026#34;MyAdd()(100,100) = \u0026#34; \u0026lt;\u0026lt; MyAdd()(100, 100) \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 4.6 继承 继承是面向对象三大特性之一\n有些类与类之间存在特殊的关系，例如下图中：\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n4.6.1 继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n普通实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 //Java页面 class Java { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;JAVA学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //Python页面 class Python { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //C++页面 class CPP { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Java页面 cout \u0026lt;\u0026lt; \u0026#34;Java下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //Python页面 cout \u0026lt;\u0026lt; \u0026#34;Python下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //C++页面 cout \u0026lt;\u0026lt; \u0026#34;C++下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 继承实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 //公共页面 class BasePage { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } }; //Java页面 class Java : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;JAVA学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //Python页面 class Python : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //C++页面 class CPP : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Java页面 cout \u0026lt;\u0026lt; \u0026#34;Java下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //Python页面 cout \u0026lt;\u0026lt; \u0026#34;Python下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //C++页面 cout \u0026lt;\u0026lt; \u0026#34;C++下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n继承的好处：==可以减少重复的代码==\nclass A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n4.6.2 继承方式 继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n公共继承 保护继承 私有继承 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Base1 { public: int m_A; protected: int m_B; private: int m_C; }; //公共继承 class Son1 :public Base1 { public: void func() { m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 } }; void myClass() { Son1 s1; s1.m_A; //其他类只能访问到公共权限 } //保护继承 class Base2 { public: int m_A; protected: int m_B; private: int m_C; }; class Son2:protected Base2 { public: void func() { m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 } }; void myClass2() { Son2 s; //s.m_A; //不可访问 } //私有继承 class Base3 { public: int m_A; protected: int m_B; private: int m_C; }; class Son3:private Base3 { public: void func() { m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 } }; class GrandSon3 :public Son3 { public: void func() { //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; } }; 4.6.3 继承中的对象模型 **问题：**从父类继承过来的成员，哪些属于子类对象中？\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Base { public: int m_A; protected: int m_B; private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去 }; //公共继承 class Son :public Base { public: int m_D; }; void test01() { cout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(Son) \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 利用工具查看：\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名\n效果如下图：\n结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n4.6.4 继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Base { public: Base() { cout \u0026lt;\u0026lt; \u0026#34;Base构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Son : public Base { public: Son() { cout \u0026lt;\u0026lt; \u0026#34;Son构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } ~Son() { cout \u0026lt;\u0026lt; \u0026#34;Son析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n4.6.5 继承同名成员处理方式 问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Base { public: Base() { m_A = 100; } void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;Base - func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; } public: int m_A; }; class Son : public Base { public: Son() { m_A = 200; } //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() { cout \u0026lt;\u0026lt; \u0026#34;Son - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } public: int m_A; }; void test01() { Son s; cout \u0026lt;\u0026lt; \u0026#34;Son下的m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base下的m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; s.func(); s.Base::func(); s.Base::func(10); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return EXIT_SUCCESS; } 总结：\n子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式 问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Base { public: static void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } static void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;Base - static void func(int a)\u0026#34; \u0026lt;\u0026lt; endl; } static int m_A; }; int Base::m_A = 100; class Son : public Base { public: static void func() { cout \u0026lt;\u0026lt; \u0026#34;Son - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } static int m_A; }; int Son::m_A = 200; //同名成员属性 void test01() { //通过对象访问 cout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; Son s; cout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; //通过类名访问 cout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::Base::m_A \u0026lt;\u0026lt; endl; } //同名成员函数 void test02() { //通过对象访问 cout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; Son s; s.func(); s.Base::func(); cout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100); } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n4.6.7 多继承语法 C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Base1 { public: Base1() { m_A = 100; } public: int m_A; }; class Base2 { public: Base2() { m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 } public: int m_A; }; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 { public: Son() { m_C = 300; m_D = 400; } public: int m_C; int m_D; }; //多继承容易产生成员同名的情况 //通过使用类名作用域可以区分调用哪一个基类的成员 void test01() { Son s; cout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.Base1::m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.Base2::m_A \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n4.6.8 菱形继承 菱形继承概念：\n​\t两个派生类继承同一个基类\n​\t又有某个类同时继承者两个派生类\n​\t这种继承被称为菱形继承，或者钻石继承\n典型的菱形继承案例：\n菱形继承问题：\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\r草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Animal { public: int m_Age; }; //继承前加virtual关键字后，变为虚继承 //此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal {}; class Tuo : virtual public Animal {}; class SheepTuo : public Sheep, public Tuo {}; void test01() { SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout \u0026lt;\u0026lt; \u0026#34;st.Sheep::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Sheep::m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;st.Tuo::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Tuo::m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;st.m_Age = \u0026#34; \u0026lt;\u0026lt; st.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态 4.7.1 多态的基本概念 多态是C++面向对象三大特性之一\n多态分为两类\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别：\n静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Animal { public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小狗在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; //我们希望传入什么对象，那么就调用什么对象的函数 //如果函数地址在编译阶段就能确定，那么静态联编 //如果函数地址在运行阶段才能确定，就是动态联编 void DoSpeak(Animal \u0026amp; animal) { animal.speak(); } // //多态满足条件： //1、有继承关系 //2、子类重写父类中的虚函数 //多态使用： //父类指针或引用指向子类对象 void test01() { Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n多态满足条件\n有继承关系 子类重写父类中的虚函数 多态使用条件\n父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n4.7.2 多态案例一-计算器类 案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 //普通实现 class Calculator { public: int getResult(string oper) { if (oper == \u0026#34;+\u0026#34;) { return m_Num1 + m_Num2; } else if (oper == \u0026#34;-\u0026#34;) { return m_Num1 - m_Num2; } else if (oper == \u0026#34;*\u0026#34;) { return m_Num1 * m_Num2; } //如果要提供新的运算，需要修改源码 } public: int m_Num1; int m_Num2; }; void test01() { //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;+\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;-\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;*\u0026#34;) \u0026lt;\u0026lt; endl; } //多态实现 //抽象计算器类 //多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator { public : virtual int getResult() { return 0; } int m_Num1; int m_Num2; }; //加法计算器 class AddCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 + m_Num2; } }; //减法计算器 class SubCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 - m_Num2; } }; //乘法计算器 class MulCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 * m_Num2; } }; void test02() { //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; } int main() { //test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n4.7.3 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为==抽象类==\n抽象类特点：\n无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Base { public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0; }; class Son :public Base { public: virtual void func() { cout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; }; }; void test01() { Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-\u0026gt;func(); delete base;//记得销毁 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7.4 多态案例二-制作饮品 案例描述：\n制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //抽象制作饮品 class AbstractDrinking { public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); } }; //制作咖啡 class Coffee : public AbstractDrinking { public: //烧水 virtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮农夫山泉!\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 virtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡咖啡!\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 virtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;将咖啡倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 virtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入牛奶!\u0026#34; \u0026lt;\u0026lt; endl; } }; //制作茶水 class Tea : public AbstractDrinking { public: //烧水 virtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮自来水!\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 virtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡茶叶!\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 virtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;将茶水倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 virtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入枸杞!\u0026#34; \u0026lt;\u0026lt; endl; } }; //业务函数 void DoWork(AbstractDrinking* drink) { drink-\u0026gt;MakeDrink(); delete drink; } void test01() { DoWork(new Coffee); cout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; DoWork(new Tea); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 4.7.5 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别：\n如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法：\nvirtual ~类名(){}\n纯虚析构语法：\nvirtual ~类名() = 0;\n类名::~类名(){}\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class Animal { public: Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; } virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //{ //\tcout \u0026lt;\u0026lt; \u0026#34;Animal虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; //} virtual ~Animal() = 0; }; Animal::~Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 纯虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; } //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 class Cat : public Animal { public: Cat(string name) { cout \u0026lt;\u0026lt; \u0026#34;Cat构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; m_Name = new string(name); } virtual void Speak() { cout \u0026lt;\u0026lt; *m_Name \u0026lt;\u0026lt; \u0026#34;小猫在说话!\u0026#34; \u0026lt;\u0026lt; endl; } ~Cat() { cout \u0026lt;\u0026lt; \u0026#34;Cat析构函数调用!\u0026#34; \u0026lt;\u0026lt; endl; if (this-\u0026gt;m_Name != NULL) { delete m_Name; m_Name = NULL; } } public: string *m_Name; }; void test01() { Animal *animal = new Cat(\u0026#34;Tom\u0026#34;); animal-\u0026gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n​\t3. 拥有纯虚析构函数的类也属于抽象类\n4.7.6 多态案例三-电脑组装 案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #include\u0026lt;iostream\u0026gt; using namespace std; //抽象CPU类 class CPU { public: //抽象的计算函数 virtual void calculate() = 0; }; //抽象显卡类 class VideoCard { public: //抽象的显示函数 virtual void display() = 0; }; //抽象内存条类 class Memory { public: //抽象的存储函数 virtual void storage() = 0; }; //电脑类 class Computer { public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 void work() { //让零件工作起来，调用接口 m_cpu-\u0026gt;calculate(); m_vc-\u0026gt;display(); m_mem-\u0026gt;storage(); } //提供析构函数 释放3个电脑零件 ~Computer() { //释放CPU零件 if (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 if (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 if (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针 }; //具体厂商 //Intel厂商 class IntelCPU :public CPU { public: virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;Intel的CPU开始计算了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelVideoCard :public VideoCard { public: virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;Intel的显卡开始显示了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelMemory :public Memory { public: virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;Intel的内存条开始存储了！\u0026#34; \u0026lt;\u0026lt; endl; } }; //Lenovo厂商 class LenovoCPU :public CPU { public: virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的CPU开始计算了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoVideoCard :public VideoCard { public: virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的显卡开始显示了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoMemory :public Memory { public: virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的内存条开始存储了！\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout \u0026lt;\u0026lt; \u0026#34;第一台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-\u0026gt;work(); delete computer1; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;第二台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-\u0026gt;work(); delete computer2; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;第三台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-\u0026gt;work(); delete computer3; } 5 文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 ==\u0026lt; fstream \u0026gt;==\n文件类型分为两种：\n文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类:\nofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件 5.1.1写文件 写文件步骤如下：\n包含头文件\n#include \u0026lt;fstream\u0026gt;\n创建流对象\nofstream ofs;\n打开文件\nofs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n写数据\nofs \u0026laquo; \u0026ldquo;写入的数据\u0026rdquo;;\n关闭文件\nofs.close();\n文件打开方式：\n打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符\n**例如：**用二进制方式写文件 ios::binary | ios:: out\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;fstream\u0026gt; void test01() { ofstream ofs; ofs.open(\u0026#34;test.txt\u0026#34;, ios::out); ofs \u0026lt;\u0026lt; \u0026#34;姓名：张三\u0026#34; \u0026lt;\u0026lt; endl; ofs \u0026lt;\u0026lt; \u0026#34;性别：男\u0026#34; \u0026lt;\u0026lt; endl; ofs \u0026lt;\u0026lt; \u0026#34;年龄：18\u0026#34; \u0026lt;\u0026lt; endl; ofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用\u0026laquo;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件 读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下：\n包含头文件\n#include \u0026lt;fstream\u0026gt;\n创建流对象\nifstream ifs;\n打开文件并判断文件是否打开成功\nifs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n读数据\n四种方式读取\n关闭文件\nifs.close();\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; void test01() { ifstream ifs; ifs.open(\u0026#34;test.txt\u0026#34;, ios::in); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } //第一种方式 //char buf[1024] = { 0 }; //while (ifs \u0026gt;\u0026gt; buf) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} //第二种 //char buf[1024] = { 0 }; //while (ifs.getline(buf,sizeof(buf))) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} //第三种 //string buf; //while (getline(ifs, buf)) //{ //\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; //} char c; while ((c = ifs.get()) != EOF) { cout \u0026lt;\u0026lt; c; } ifs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ==ios::binary==\n5.2.1 写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: char m_Name[64]; int m_Age; }; //二进制文件 写文件 void test01() { //1、包含头文件 //2、创建输出流对象 ofstream ofs(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); //3、打开文件 //ofs.open(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); Person p = {\u0026#34;张三\u0026#34; , 18}; //4、写文件 ofs.write((const char *)\u0026amp;p, sizeof(p)); //5、关闭文件 ofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件 二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: char m_Name[64]; int m_Age; }; void test01() { ifstream ifs(\u0026#34;person.txt\u0026#34;, ios::in | ios::binary); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; } Person p; ifs.read((char *)\u0026amp;p, sizeof(p)); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 文件输入流对象 可以通过read函数，以二进制方式读数据 ","date":"2023-09-10T00:00:00Z","image":"https://www.happylee.cn/post/cpp-core/CPP-COVER.png","permalink":"https://www.happylee.cn/post/cpp-core/","title":"C++核心编程"},{"content":" 前言：\n在这里首先特别感谢安知鱼大佬的贡献！本文改编自安知鱼的一篇教程——Heo同款loading动画 对比上面的安知鱼那篇原文，本文主要新增了关于loading动画下的百分比加载数字的效果 本篇文章仅用于交流学习之用，若有侵权行为，请联系我删除 效果展示 1.Butterfly主题自带页面加载动画 preloader： 关于如何开启页面加载动画的方法，请参照——Butterfly 安装文档(四) 主题配置-2 2.魔改后的loading加载动画： 魔改后的加载动画更加简洁，并且上面的头像、背景颜色等支持用户自定义，能够更加切合自己的网站风格\n操作方法 提示：\n本教程适用于Butterfly主题4.5以上版本（实测为4.7.0版本）\n本文中需要改动的有关文件，我均已整理并打包上传至我的GitHub仓库：https://github.com/HappyLeeCode/Butterfly-Loading\n1.修改 {% label themes/butterfly/layout/includes/loading/fullpage-loading.pug %}\n下方的图片链接记得换成自己的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 - loading_img = theme.preloader.avatar #loading-box(onclick=\u0026#39;document.getElementById(\u0026#34;loading-box\u0026#34;).classList.add(\u0026#34;loaded\u0026#34;)\u0026#39;) .loading-bg img.loading-img(class=\u0026#39;nolazyload\u0026#39; src=loading_img ? url_for(loading_img) : \u0026#34;https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/img/avatar.webp\u0026#34;) .loading-image-dot #loading-percentage | 0% script. const loadingPercentage = document.getElementById(\u0026#34;loading-percentage\u0026#34;); loadingPercentage.style.color = \u0026#34;black\u0026#34;; let loadingPercentageTimer = setInterval(function() { var progressBar = document.querySelector(\u0026#34;.pace-progress\u0026#34;); if (!progressBar) return var currentValue = progressBar.getAttribute(\u0026#34;data-progress-text\u0026#34;); if (currentValue !== loadingPercentage.textContent) { loadingPercentage.textContent = currentValue; if (currentValue === \u0026#34;100%\u0026#34;) { clearInterval(loadingPercentageTimer); } } }, 100); const preloader = { endLoading: () =\u0026gt; { document.body.style.overflow = \u0026#39;auto\u0026#39;; document.getElementById(\u0026#39;loading-box\u0026#39;).classList.add(\u0026#34;loaded\u0026#34;) }, initLoading: () =\u0026gt; { document.body.style.overflow = \u0026#39;\u0026#39;; document.getElementById(\u0026#39;loading-box\u0026#39;).classList.remove(\u0026#34;loaded\u0026#34;) } } window.addEventListener(\u0026#39;load\u0026#39;,()=\u0026gt; { preloader.endLoading() }) if (!{theme.pjax \u0026amp;\u0026amp; theme.pjax.enable}) { document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { preloader.initLoading() }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { preloader.endLoading() }) } 2.修改 {% label themes/butterfly/layout/includes/loading/index.pug %}\n1 2 3 4 5 6 7 if theme.preloader.source === 1 include ./fullpage-loading.pug else if theme.preloader.source === 2 include ./pace.pug else include ./fullpage-loading.pug include ./pace.pug 3.新建博客根目录下{% label source/css/progress_bar.css %} , 也可以不做这一步,那么最后一步中修改配置文件{% label pace_css_url %} 这一项就要留空, 这一步其是修改 pace 加载的胶囊 💊 样式用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 .pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; z-index: 2000; position: fixed; margin: auto; top: 10px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 4rem; background: #eaecf2; border: 1px #e3e8f7; overflow: hidden; } .pace-inactive .pace-progress { opacity: 0; transition: 0.3s ease-in; } .pace .pace-progress { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); -o-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); max-width: 200px; position: absolute; z-index: 2000; display: block; top: 0; right: 100%; height: 100%; width: 100%; background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab); animation: gradient 1.5s ease infinite; background-size: 200%; } .pace.pace-inactive { opacity: 0; transition: 0.3s; top: -8px; } @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } 4.修改{% label themes/butterfly/source/css/_layout/loading.styl %} 。\n注意：其中**.loading-bg那一项下的background**可以自行修改为自己的色值\n（这里其实就是在修改加载背景的颜色，例如我的颜色是浅蓝色：#B0E2FF）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 if hexo-config(\u0026#39;preloader\u0026#39;) .loading-bg display: flex; width: 100%; height: 100%; position: fixed; background: #B0E2FF; z-index: 1001; opacity: 1; transition: .3s; #loading-box .loading-img width: 100px; height: 100px; border-radius: 50%; margin: auto; border: 4px solid #f0f0f2; animation-duration: .3s; animation-name: loadingAction; animation-iteration-count: infinite; animation-direction: alternate; .loading-image-dot width: 30px; height: 30px; background: #6bdf8f; position: absolute; border-radius: 50%; border: 6px solid #fff; top: 50%; left: 50%; transform: translate(18px, 24px); #loading-percentage position: absolute; top: 67%; left: 50%; transform: translateX(-50%); \u0026amp;::before content: \u0026#34;「\u0026#34; margin-right: 10px \u0026amp;::after content: \u0026#34;」\u0026#34; margin-left: 10px \u0026amp;.loaded .loading-bg opacity: 0; z-index: -1000; @keyframes loadingAction 0% { opacity: 1; } 100% { opacity: .4; } 5.在合适的地方加上自定义 css, 其中 background 的 url 即为 loading 的图片地址。\n（不会的同学参考Hexo 博客添加自定义 css 和 js 文件）\n1 2 3 4 .loading-img { background: url(https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/img/avatar.webp) no-repeat center center; background-size: cover; } 6.最后一步：修改主题目录下{% label _config.yml %}中preloader选项,。\n现在 source: 1为满屏加载，无pace胶囊；source: 2为pace胶囊，无满屏动画；source: 3是两者都启用。\n1 2 3 4 5 6 7 8 9 # Loading Animation (加載動畫) preloader: enable: true # source # 1. fullpage-loading # 2. pace (progress bar) source: 3 # pace theme (see https://codebyzach.github.io/pace/) pace_css_url: /css/progress_bar.css 后文 至此，本篇文章就结束了。码字不易，还请多多支持本站，欢迎您的后续关注！\n另外，如果您有什么问题，或者发现了文中的一些错误，都欢迎您在下方评论区留言和我交流、讨论！\n","date":"2023-08-03T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/cover/loading.png","permalink":"https://www.happylee.cn/post/butterfly-loading/","title":"一款基于Butterfly主题的loading动画"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档 本部分的实验报告适用于电子信息工程专业，其他专业仅供参考 严禁直接抄袭本报告、复制粘贴改名等学术不端行为 一、设计目的 通过电子通信设备的组装实习，要求掌握基本的焊接技术，学会元器件识别、测试和安装的方法，掌握万用表的使用方法，掌握电子通信设备的工作原理，学会识别电路原理图与印刷图，学会利用工艺文件独立进行电子通信设备的整机装配、调试方法，并达到产品的质量要求，从而锻炼和提高学生的动手能力，巩固和加深对电子学理论知识的理解和掌握，为以后专业设计、课程设计及毕业设计准备必要的工艺知识和操作技能。\n通过电器的安装制作，熟悉电子仪器的安装制作过程和电路的调试及简单故障排除的技能，能够在安装制作过程中考虑经济因素。 能够站在环境保护和可持续发展的角度思考电子信息工程实践的可持续性，正确评价电子产品周期中可能对人类和环境造成的损害和隐患。 二、设计任务 FM调频收音机电路设计与实现。设计并实现一个基于电子元器件的FM调频收音机，包括收音、解调、放音等功能。具体任务如下：\n设计FM收音电路，实现调频收音功能；设计解调电路，将调频信号转化为模拟音频信号； 设计音频放大电路，使音频信号能够放大并输出到扬声器； 搭建完整的FM调频收音电路原型，并进行测试和调试，确保其稳定运行； 所有元器件的费用不超过100元。 三、实习报告 Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档\n严禁直接抄袭本报告、复制粘贴改名等学术不端行为！\n","date":"2023-07-05T00:00:00Z","permalink":"https://www.happylee.cn/post/design-fm-radio/","title":"基于RDA5807收音模块的FM调频收音机设计"},{"content":"NOW 期末临近，同时我也想放空一下自己，使自己能够更加专注地做好自己当下的事情。无论是课程设计、实验报告，还是结课考试，作为一名学生，我都希望自己能够处理好它们。因此，我决定暂时停止博客网站内容上的更新。\n本次停更时间预计两个月。我计划在完成好期末考试后，利用后面的假期时间继续完成有关方面的学习，并努力锤炼和打磨好自己的技术。\nNEXT 同时，我也会在本次停更期间，对网站上的内容和板块进行一次更大的升级，预计将在八月中旬左右完成和上线：\nMy Flag：\n自学完C++程序设计的面向对象以及泛型编程等特性，并将在本网站相关板块上传和完善好该内容 目前我在学校期间完成了一次电子工艺实习，考虑后面在网站上展示这次关于收音机的实现过程 我会在假期内继续完成有关51单片机的学习，记录相关的学习笔记和收获，并更新相关板块的内容 我考虑停更期间对网站的主题页面、板块栏目、访问速度等进行一次大规模的维护和升级，以谋求更好的访问体验！ 这些新的内容将在下一次网站更新后上线，预计将在八月中旬左右完成，敬请期待！！！\n另外，如果您有什么问题，以及对网站的一些建议，都欢迎您在下方评论区留言和我交流、讨论！\n","date":"2023-06-11T00:00:00Z","image":"https://www.happylee.cn/post/2023.6.11%E5%81%9C%E6%9B%B4%E5%85%AC%E5%91%8A/notic.png","permalink":"https://www.happylee.cn/post/2023.6.11%E5%81%9C%E6%9B%B4%E5%85%AC%E5%91%8A/","title":"2023.6.11停更公告"},{"content":"C++基础入门 1 C++初识 1.1 第一个C++程序 编写一个C++程序总共分为4个步骤\n创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目 ​\tVisual Studio是我们用来编写C++程序的主要工具，我们先将它打开\n1.1.2 创建文件 右键源文件，选择添加-\u0026gt;新建项\n给C++文件起个名称，然后点击添加即可。\n1.1.3 编写代码 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 1.1.4 运行程序 1.2 注释 作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码\n两种格式\n单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容\n1.3 变量 作用：给一段指定的内存空间起名，方便操作这段内存\n语法：数据类型 变量名 = 初始值;\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C++在创建变量时，必须给变量一个初始值，否则会报错\n1.4 常量 作用：用于记录程序中不可更改的数据\nC++定义常量两种方式\n#define 宏常量： #define 常量名 常量值\n==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值\n==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //1、宏常量 #define day 7 int main() { cout \u0026lt;\u0026lt; \u0026#34;一周里总共有 \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34; 天\u0026#34; \u0026lt;\u0026lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout \u0026lt;\u0026lt; \u0026#34;一年里总共有 \u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34; 个月份\u0026#34; \u0026lt;\u0026lt; endl; //month = 24; //报错，常量是不可以修改的 system(\u0026#34;pause\u0026#34;); return 0; } 1.5 关键字 **作用：**关键字是C++中预先保留的单词（标识符）\n在定义变量或者常量时候，不要用关键字 C++关键字如下：\nasm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。\n1.6 标识符命名规则 作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则\n标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读\n2 数据类型 C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存\n2.1 整型 作用：整型变量表示的是==整数类型==的数据\nC++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字 **作用：**利用sizeof关键字可以==统计数据类型所占内存大小==\n语法： sizeof( 数据类型 / 变量)\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { cout \u0026lt;\u0026lt; \u0026#34;short 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long long 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 整型结论：==short \u0026lt; int \u0026lt;= long \u0026lt;= long long==\n2.3 实型（浮点型） 作用：用于==表示小数==\n浮点型变量分为两种：\n单精度float 双精度double 两者的区别在于表示的有效数字范围不同。\n数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { float f1 = 3.14f; double d1 = 3.14; cout \u0026lt;\u0026lt; f1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d1\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float sizeof = \u0026#34; \u0026lt;\u0026lt; sizeof(f1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;double sizeof = \u0026#34; \u0026lt;\u0026lt; sizeof(d1) \u0026lt;\u0026lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout \u0026lt;\u0026lt; \u0026#34;f2 = \u0026#34; \u0026lt;\u0026lt; f2 \u0026lt;\u0026lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout \u0026lt;\u0026lt; \u0026#34;f3 = \u0026#34; \u0026lt;\u0026lt; f3 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.4 字符型 **作用：**字符型变量用于显示单个字符\n语法：char ch = 'a';\n注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号\n注意2：单引号内只能有一个字符，不可以是字符串\nC和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { char ch = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; //ch = \u0026#34;abcde\u0026#34;; //错误，不可以用双引号 //ch = \u0026#39;abcde\u0026#39;; //错误，单引号内只能引用一个字符 cout \u0026lt;\u0026lt; (int)ch \u0026lt;\u0026lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ASCII码表格：\nASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \u0026quot; 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u0026lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u0026gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成：\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符 **作用：**用于表示一些==不能显示出来的ASCII字符==\n现阶段我们常用的转义字符有： \\n \\\\ \\t\n转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符\u0026quot;\u0026quot; 092 ' 代表一个单引号（撇号）字符 039 \u0026quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围0~9，a~f，A~F 3位16进制 示例：\n1 2 3 4 5 6 7 8 9 10 11 int main() { cout \u0026lt;\u0026lt; \u0026#34;\\\\\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tHello\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.6 字符串型 作用：用于表示一串字符\n两种风格\nC风格字符串： char 变量名[] = \u0026quot;字符串值\u0026quot;\n示例：\n1 2 3 4 5 6 7 8 9 int main() { char str1[] = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C风格的字符串要用双引号括起来\nC++风格字符串： string 变量名 = \u0026quot;字符串值\u0026quot;\n示例：\n1 2 3 4 5 6 7 8 9 int main() { string str = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C++风格字符串，需要加入头文件==#include\u0026lt;string\u0026gt;==\n2.7 布尔类型 bool **作用：**布尔数据类型代表真或假的值\nbool类型只有两个值：\ntrue \u0026mdash; 真（本质是1） false \u0026mdash; 假（本质是0） bool类型占==1个字节==大小\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { bool flag = true; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; // 1 flag = false; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; \u0026#34;size of bool = \u0026#34; \u0026lt;\u0026lt; sizeof(bool) \u0026lt;\u0026lt; endl; //1 system(\u0026#34;pause\u0026#34;); return 0; } 2.8 数据的输入 作用：用于从键盘获取数据\n**关键字：**cin\n语法： cin \u0026gt;\u0026gt; 变量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int main(){ //整型输入 int a = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入整型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //浮点型输入 double d = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入浮点型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; //字符型输入 char ch = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入字符型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ch; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; //字符串型输入 string str; cout \u0026lt;\u0026lt; \u0026#34;请输入字符串型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; str; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; //布尔类型输入 bool flag = true; cout \u0026lt;\u0026lt; \u0026#34;请输入布尔型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; flag; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return EXIT_SUCCESS; } 3 运算符 **作用：**用于执行代码的运算\n本章我们主要讲解以下几类运算符：\n运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符 作用：用于处理四则运算\n算术运算符包括以下符号：\n运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1; \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2; 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //加减乘除 int main() { int a1 = 10; int b1 = 3; cout \u0026lt;\u0026lt; a1 + b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 - b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 * b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 / b1 \u0026lt;\u0026lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout \u0026lt;\u0026lt; a2 / b2 \u0026lt;\u0026lt; endl; int a3 = 10; int b3 = 0; //cout \u0026lt;\u0026lt; a3 / b3 \u0026lt;\u0026lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout \u0026lt;\u0026lt; d1 / d2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：在除法运算中，除数不能为0\n示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //取模 int main() { int a1 = 10; int b1 = 3; cout \u0026lt;\u0026lt; 10 % 3 \u0026lt;\u0026lt; endl; int a2 = 10; int b2 = 20; cout \u0026lt;\u0026lt; a2 % b2 \u0026lt;\u0026lt; endl; int a3 = 10; int b3 = 0; //cout \u0026lt;\u0026lt; a3 % b3 \u0026lt;\u0026lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout \u0026lt;\u0026lt; d1 % d2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：只有整型变量可以进行取模运算\n示例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //递增 int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 11 //前置递增 int b = 10; ++b; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout \u0026lt;\u0026lt; b2 \u0026lt;\u0026lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout \u0026lt;\u0026lt; b3 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：前置递增先对变量进行++，再计算表达式，后置递增相反\n3.2 赋值运算符 **作用：**用于将表达式的值赋给变量\n赋值运算符包括以下几个符号：\n运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int main() { //赋值运算符 // = int a = 10; a = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // += a = 10; a += 2; // a = a + 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 3.3 比较运算符 **作用：**用于表达式的比较，并返回一个真值或假值\n比较运算符有以下符号：\n运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 \u0026lt; 小于 4 \u0026lt; 3 0 \u0026gt; 大于 4 \u0026gt; 3 1 \u0026lt;= 小于等于 4 \u0026lt;= 3 0 \u0026gt;= 大于等于 4 \u0026gt;= 1 1 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int a = 10; int b = 20; cout \u0026lt;\u0026lt; (a == b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a != b) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (a \u0026gt; b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a \u0026lt; b) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (a \u0026gt;= b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a \u0026lt;= b) \u0026lt;\u0026lt; endl; // 1 system(\u0026#34;pause\u0026#34;); return 0; } 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。==\n3.4 逻辑运算符 **作用：**用于根据表达式的值返回真值或假值\n逻辑运算符有以下符号：\n运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 \u0026amp;\u0026amp; 与 a \u0026amp;\u0026amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 **示例1：**逻辑非\n1 2 3 4 5 6 7 8 9 10 11 12 13 //逻辑运算符 --- 非 int main() { int a = 10; cout \u0026lt;\u0026lt; !a \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; !!a \u0026lt;\u0026lt; endl; // 1 system(\u0026#34;pause\u0026#34;); return 0; } 总结： 真变假，假变真\n**示例2：**逻辑与\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //逻辑运算符 --- 与 int main() { int a = 10; int b = 10; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 1 a = 10; b = 0; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 0 a = 0; b = 0; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 0 system(\u0026#34;pause\u0026#34;); return 0; } 总结：逻辑==与==运算符总结： ==同真为真，其余为假==\n**示例3：**逻辑或\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //逻辑运算符 --- 或 int main() { int a = 10; int b = 10; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 1 a = 10; b = 0; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 1 a = 0; b = 0; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 0 system(\u0026#34;pause\u0026#34;); return 0; } 逻辑==或==运算符总结： ==同假为假，其余为真==\n4 程序流程结构 C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==\n顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构 4.1.1 if语句 **作用：**执行满足条件的语句\nif语句的三种形式\n单行格式if语句\n多行格式if语句\n多条件的if语句\n单行格式if语句：if(条件){ 条件满足执行的语句 }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入一个分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; cout \u0026lt;\u0026lt; \u0026#34;您输入的分数为： \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学！！！\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：if条件表达式后不要加分号\n多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上一本大学\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 500) { cout \u0026lt;\u0026lt; \u0026#34;我考上了二本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 400) { cout \u0026lt;\u0026lt; \u0026#34;我考上了三本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上本科\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断\n案例需求：\n提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; if (score \u0026gt; 700) { cout \u0026lt;\u0026lt; \u0026#34;我考上了北大\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 650) { cout \u0026lt;\u0026lt; \u0026#34;我考上了清华\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我考上了人大\u0026#34; \u0026lt;\u0026lt; endl; } } else if (score \u0026gt; 500) { cout \u0026lt;\u0026lt; \u0026#34;我考上了二本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 400) { cout \u0026lt;\u0026lt; \u0026#34;我考上了三本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上本科\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 练习案例： 三只小猪称体重\n有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？\n4.1.2 三目运算符 作用： 通过三目运算符实现简单的判断\n语法：表达式1 ? 表达式2 ：表达式3\n解释：\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int a = 10; int b = 20; int c = 0; c = a \u0026gt; b ? a : b; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a \u0026gt; b ? a : b) = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰\n4.1.3 switch语句 **作用：**执行多条件分支语句\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) { case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请给电影打分\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; switch (score) { case 10: case 9: cout \u0026lt;\u0026lt; \u0026#34;经典\u0026#34; \u0026lt;\u0026lt; endl; break; case 8: cout \u0026lt;\u0026lt; \u0026#34;非常好\u0026#34; \u0026lt;\u0026lt; endl; break; case 7: case 6: cout \u0026lt;\u0026lt; \u0026#34;一般\u0026#34; \u0026lt;\u0026lt; endl; break; default: cout \u0026lt;\u0026lt; \u0026#34;烂片\u0026#34; \u0026lt;\u0026lt; endl; break; } system(\u0026#34;pause\u0026#34;); return 0; } 注意1：switch语句中表达式类型只能是整型或者字符型\n注意2：case里如果没有break，那么程序会一直向下执行\n总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\n4.2 循环结构 4.2.1 while循环语句 **作用：**满足循环条件，执行循环语句\n语法： while(循环条件){ 循环语句 }\n解释：==只要循环条件的结果为真，就执行循环语句==\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int num = 0; while (num \u0026lt; 10) { cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; num++; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环\nwhile循环练习案例：==猜数字==\n**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。\n4.2.2 do\u0026hellip;while循环语句 作用： 满足循环条件，执行循环语句\n语法： do{ 循环语句 } while(循环条件);\n**注意：**与while的区别在于==do\u0026hellip;while会先执行一次循环语句==，再判断循环条件\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { int num = 0; do { cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; num++; } while (num \u0026lt; 10); system(\u0026#34;pause\u0026#34;); return 0; } 总结：与while循环区别在于，do\u0026hellip;while先执行一次循环语句，再判断循环条件\n练习案例：水仙花数\n**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身\n例如：1^3 + 5^3+ 3^3 = 153\n请利用do\u0026hellip;while语句，求出所有3位数中的水仙花数\n4.2.3 for循环语句 作用： 满足循环条件，执行循环语句\n语法： for(起始表达式;条件表达式;末尾循环体) { 循环语句; }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 int main() { for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 详解：\n注意：for循环中的表达式，要用分号进行分隔\n总结：while , do\u0026hellip;while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用\n练习案例：敲桌子\n案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。\n4.2.4 嵌套循环 作用： 在循环体中再嵌套一层循环，解决一些实际问题\n例如我们想在屏幕中打印如下图片，就需要利用嵌套循环\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i \u0026lt; 10; i++) { for (int j = 0; j \u0026lt; 10; j++) { cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } **练习案例：**乘法口诀表\n案例描述：利用嵌套循环，实现九九乘法表\n4.3 跳转语句 4.3.1 break语句 作用: 用于跳出==选择结构==或者==循环结构==\nbreak使用的时机：\n出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { //1、在switch 语句中使用break cout \u0026lt;\u0026lt; \u0026#34;请选择您挑战副本的难度：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1、普通\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2、中等\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3、困难\u0026#34; \u0026lt;\u0026lt; endl; int num = 0; cin \u0026gt;\u0026gt; num; switch (num) { case 1: cout \u0026lt;\u0026lt; \u0026#34;您选择的是普通难度\u0026#34; \u0026lt;\u0026lt; endl; break; case 2: cout \u0026lt;\u0026lt; \u0026#34;您选择的是中等难度\u0026#34; \u0026lt;\u0026lt; endl; break; case 3: cout \u0026lt;\u0026lt; \u0026#34;您选择的是困难难度\u0026#34; \u0026lt;\u0026lt; endl; break; } system(\u0026#34;pause\u0026#34;); return 0; } 示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { //2、在循环语句中用break for (int i = 0; i \u0026lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 示例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i \u0026lt; 10; i++) { for (int j = 0; j \u0026lt; 10; j++) { if (j == 5) { break; } cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 4.3.2 continue语句 **作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { for (int i = 0; i \u0026lt; 100; i++) { if (i % 2 == 0) { continue; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：continue并没有使整个循环终止，而break会跳出循环\n4.3.3 goto语句 **作用：**可以无条件跳转语句\n语法： goto 标记;\n**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34; \u0026lt;\u0026lt; endl; goto FLAG; cout \u0026lt;\u0026lt; \u0026#34;2\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4\u0026#34; \u0026lt;\u0026lt; endl; FLAG: cout \u0026lt;\u0026lt; \u0026#34;5\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：在程序中不建议使用goto语句，以免造成程序流程混乱\n5 数组 5.1 概述 所谓数组，就是一个集合，里面存放了相同类型的数据元素\n**特点1：**数组中的每个==数据元素都是相同的数据类型==\n**特点2：**数组是由==连续的内存==位置组成的\n5.2 一维数组 5.2.1 一维数组定义方式 一维数组定义的三种方式：\n数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout \u0026lt;\u0026lt; score[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; score[1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; score[2] \u0026lt;\u0026lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout \u0026lt;\u0026lt; score2[0] \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; score2[1] \u0026lt;\u0026lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; score2[i] \u0026lt;\u0026lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; score3[i] \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名\n总结2：数组中下标是从0开始索引\n5.2.2 一维数组数组名 一维数组名称的用途：\n可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout \u0026lt;\u0026lt; \u0026#34;整个数组所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;每个元素所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组的元素个数为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; //2、可以通过数组名获取到数组首地址 cout \u0026lt;\u0026lt; \u0026#34;数组首地址为： \u0026#34; \u0026lt;\u0026lt; (int)arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组中第一个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组中第二个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[1] \u0026lt;\u0026lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(\u0026#34;pause\u0026#34;); return 0; } 注意：数组名是常量，不可以赋值\n总结1：直接打印数组名，可以查看数组所占内存的首地址\n总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n练习案例1：五只小猪称体重\n案例描述：\n在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};\n找出并打印最重的小猪体重。\n**练习案例2：**数组元素逆置\n**案例描述：**请声明一个5个元素的数组，并且将元素逆置.\n(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);\n5.2.3 冒泡排序 作用： 最常用的排序算法，对数组内元素进行排序\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i \u0026lt; 9 - 1; i++) { for (int j = 0; j \u0026lt; 9 - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i \u0026lt; 9; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 5.3 二维数组 二维数组就是在一维数组上，多加一个维度。\n5.3.1 二维数组定义方式 二维数组定义的四种方式：\n数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(\u0026#34;pause\u0026#34;); return 0; } 总结：在定义二维数组时，如果初始化了数据，可以省略行数\n5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout \u0026lt;\u0026lt; \u0026#34;二维数组大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组一行大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组元素大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组行数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组列数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; //地址 cout \u0026lt;\u0026lt; \u0026#34;二维数组首地址：\u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第一行地址：\u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第二行地址：\u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第一个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第二个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][1] \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结1：二维数组名就是这个数组的首地址\n总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n5.3.3 二维数组应用案例 考试成绩统计：\n案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩\n语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { \u0026#34;张三\u0026#34;,\u0026#34;李四\u0026#34;,\u0026#34;王五\u0026#34; }; for (int i = 0; i \u0026lt; 3; i++) { int sum = 0; for (int j = 0; j \u0026lt; 3; j++) { sum += scores[i][j]; } cout \u0026lt;\u0026lt; names[i] \u0026lt;\u0026lt; \u0026#34;同学总成绩为： \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 6 函数 6.1 概述 **作用：**将一段经常使用的代码封装起来，减少重复代码\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\n6.2 函数的定义 函数的定义一般主要有5个步骤：\n1、返回值类型\n2、函数名\n3、参数表列\n4、函数体语句\n5、return 表达式\n语法：\n1 2 3 4 5 6 7 8 返回值类型 函数名 （参数列表） { 函数体语句 return表达式 } 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 **示例：**定义一个加法函数，实现两个数相加\n1 2 3 4 5 6 //函数定义 int add(int num1, int num2) { int sum = num1 + num2; return sum; } 6.3 函数的调用 **功能：**使用定义好的函数\n语法： 函数名（参数）\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //函数定义 int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参 { int sum = num1 + num2; return sum; } int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; a = 100; b = 100; sum = add(a, b); cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参\n6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void swap(int num1, int num2) { cout \u0026lt;\u0026lt; \u0026#34;交换前：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num1 = \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num2 = \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; int temp = num1; num1 = num2; num2 = temp; cout \u0026lt;\u0026lt; \u0026#34;交换后：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num1 = \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num2 = \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return } int main() { int a = 10; int b = 20; swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;mian中的 a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mian中的 b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结： 值传递时，形参是修饰不了实参的\n6.5 函数的常见样式 常见的函数样式有4种\n无参无返 有参无返 无参有返 有参有返 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //函数常见样式 //1、 无参无返 void test01() { //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout \u0026lt;\u0026lt; \u0026#34;this is test01\u0026#34; \u0026lt;\u0026lt; endl; //test01(); 函数调用 } //2、 有参无返 void test02(int a) { cout \u0026lt;\u0026lt; \u0026#34;this is test02\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } //3、无参有返 int test03() { cout \u0026lt;\u0026lt; \u0026#34;this is test03 \u0026#34; \u0026lt;\u0026lt; endl; return 10; } //4、有参有返 int test04(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;this is test04 \u0026#34; \u0026lt;\u0026lt; endl; int sum = a + b; return sum; } 6.6 函数的声明 作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n函数的声明可以多次，但是函数的定义只能有一次 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //声明可以多次，定义只能一次 //声明 int max(int a, int b); int max(int a, int b); //定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } int main() { int a = 100; int b = 200; cout \u0026lt;\u0026lt; max(a, b) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 6.7 函数的分文件编写 **作用：**让代码结构更加清晰\n函数分文件编写一般有4个步骤\n创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例：\n1 2 3 4 5 6 //swap.h文件 #include\u0026lt;iostream\u0026gt; using namespace std; //实现两个数字交换的函数声明 void swap(int a, int b); 1 2 3 4 5 6 7 8 9 10 11 12 //swap.cpp文件 #include \u0026#34;swap.h\u0026#34; void swap(int a, int b) { int temp = a; a = b; b = temp; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 //main函数文件 #include \u0026#34;swap.h\u0026#34; int main() { int a = 100; int b = 200; swap(a, b); system(\u0026#34;pause\u0026#34;); return 0; } 7 指针 7.1 指针的基本概念 指针的作用： 可以通过指针间接访问内存\n内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用 指针变量定义语法： 数据类型 * 变量名；\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = \u0026amp;a; //指针指向变量a的地址 cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //打印数据a的地址 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 指针变量和普通变量的区别\n普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过\u0026quot; * \u0026ldquo;操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 \u0026amp; 符号 获取变量的地址\n总结2：利用指针可以记录地址\n总结3：对指针变量解引用，可以操作指针指向的内存\n7.3 指针所占内存空间 提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int a = 10; int * p; p = \u0026amp;a; //指针指向数据a的地址 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //* 解引用 cout \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(char *) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(float *) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(double *) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：所有指针类型在32位操作系统下是4个字节\n7.4 空指针和野指针 空指针：指针变量指向内存中编号为0的空间\n**用途：**初始化指针变量\n**注意：**空指针指向的内存是不可以访问的\n示例1：空指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 野指针：指针变量指向非法的内存空间\n示例2：野指针\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n7.5 const修饰指针 const修饰指针有三种情况\nconst修饰指针 \u0026mdash; 常量指针 const修饰常量 \u0026mdash; 指针常量 const即修饰指针，又修饰常量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = \u0026amp;a; p1 = \u0026amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = \u0026amp;a; //p2 = \u0026amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = \u0026amp;a; //p3 = \u0026amp;b; //错误 //*p3 = 100; //错误 system(\u0026#34;pause\u0026#34;); return 0; } 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n7.6 指针和数组 **作用：**利用指针访问数组中元素\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout \u0026lt;\u0026lt; \u0026#34;第一个元素： \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;指针访问第一个元素： \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; i++) { //利用指针遍历数组 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p++; } system(\u0026#34;pause\u0026#34;); return 0; } 7.7 指针和函数 **作用：**利用指针作函数参数，可以修改实参的值\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //值传递 void swap1(int a ,int b) { int temp = a; a = b; b = temp; } //地址传递 void swap2(int * p1, int *p2) { int temp = *p1; *p1 = *p2; *p2 = temp; } int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(\u0026amp;a, \u0026amp;b); //地址传递会改变实参 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n7.8 指针、数组、函数 **案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序\n例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //冒泡排序函数 void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[] { for (int i = 0; i \u0026lt; len - 1; i++) { for (int j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组函数 void printArray(int arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } } int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(\u0026#34;pause\u0026#34;); return 0; } 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针\n8 结构体 8.1 结构体基本概念 结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型\n8.2 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 }；\n通过结构体创建变量的方式有三种：\nstruct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值\u0026hellip;} 定义结构体时顺便创建变量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = \u0026#34;张三\u0026#34;; stu1.age = 18; stu1.score = 100; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu1.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu1.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu1.score \u0026lt;\u0026lt; endl; //结构体变量创建方式2 struct student stu2 = { \u0026#34;李四\u0026#34;,19,60 }; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu2.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu2.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu2.score \u0026lt;\u0026lt; endl; stu3.name = \u0026#34;王五\u0026#34;; stu3.age = 18; stu3.score = 80; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu3.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu3.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu3.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结1：定义结构体时的关键字是struct，不可省略\n总结2：创建结构体变量时，关键字struct可以省略\n总结3：结构体变量利用操作符 \u0026lsquo;\u0026rsquo;.\u0026rsquo;\u0026rsquo; 访问成员\n8.3 结构体数组 **作用：**将自定义的结构体放入到数组中方便维护\n语法： struct 结构体名 数组名[元素个数] = { {} , {} , ... {} }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 } int main() { //结构体数组 struct student arr[3]= { {\u0026#34;张三\u0026#34;,18,80 }, {\u0026#34;李四\u0026#34;,19,60 }, {\u0026#34;王五\u0026#34;,20,70 } }; for (int i = 0; i \u0026lt; 3; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; arr[i].score \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 8.4 结构体指针 **作用：**通过指针访问结构体中的成员\n利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; int main() { struct student stu = { \u0026#34;张三\u0026#34;,18,100, }; struct student * p = \u0026amp;stu; p-\u0026gt;score = 80; //指针通过 -\u0026gt; 操作符可以访问成员 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：结构体指针可以通过 -\u0026gt; 操作符 来访问结构体中的成员\n8.5 结构体嵌套结构体 作用： 结构体中的成员可以是另一个结构体\n**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //教师结构体定义 struct teacher { //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生 }; int main() { struct teacher t1; t1.id = 10000; t1.name = \u0026#34;老王\u0026#34;; t1.age = 40; t1.stu.name = \u0026#34;张三\u0026#34;; t1.stu.age = 18; t1.stu.score = 100; cout \u0026lt;\u0026lt; \u0026#34;教师 职工编号： \u0026#34; \u0026lt;\u0026lt; t1.id \u0026lt;\u0026lt; \u0026#34; 姓名： \u0026#34; \u0026lt;\u0026lt; t1.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; t1.age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;辅导学员 姓名： \u0026#34; \u0026lt;\u0026lt; t1.stu.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; t1.stu.age \u0026lt;\u0026lt; \u0026#34; 考试分数： \u0026#34; \u0026lt;\u0026lt; t1.stu.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } **总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题\n8.6 结构体做函数参数 **作用：**将结构体作为参数向函数中传递\n传递方式有两种：\n值传递 地址传递 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //值传递 void printStudent(student stu ) { stu.age = 28; cout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; } //地址传递 void printStudent2(student *stu) { stu-\u0026gt;age = 28; cout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; } int main() { student stu = { \u0026#34;张三\u0026#34;,18,100}; //值传递 printStudent(stu); cout \u0026lt;\u0026lt; \u0026#34;主函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; //地址传递 printStudent2(\u0026amp;stu); cout \u0026lt;\u0026lt; \u0026#34;主函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递\n8.7 结构体中 const使用场景 **作用：**用const来防止误操作\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //const使用场景 void printStudent(const student *stu) //加const防止函数体中的误操作 { //stu-\u0026gt;age = 100; //操作失败，因为加了const修饰 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; } int main() { student stu = { \u0026#34;张三\u0026#34;,18,100 }; printStudent(\u0026amp;stu); system(\u0026#34;pause\u0026#34;); return 0; } 8.8 结构体案例 8.8.1 案例1 案例描述：\n学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下\n设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员\n学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值\n最终打印出老师数据以及老师所带的学生数据。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct Student { string name; int score; }; struct Teacher { string name; Student sArray[5]; }; void allocateSpace(Teacher tArray[] , int len) { string tName = \u0026#34;教师\u0026#34;; string sName = \u0026#34;学生\u0026#34;; string nameSeed = \u0026#34;ABCDE\u0026#34;; for (int i = 0; i \u0026lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j \u0026lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } } } void printTeachers(Teacher tArray[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; tArray[i].name \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 5; j++) { cout \u0026lt;\u0026lt; \u0026#34;\\t姓名：\u0026#34; \u0026lt;\u0026lt; tArray[i].sArray[j].name \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; tArray[i].sArray[j].score \u0026lt;\u0026lt; endl; } } } int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include \u0026lt;ctime\u0026gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(\u0026#34;pause\u0026#34;); return 0; } 8.8.2 案例2 案例描述：\n设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。\n通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。\n五名英雄信息如下：\n1 2 3 4 5 {\u0026#34;刘备\u0026#34;,23,\u0026#34;男\u0026#34;}, {\u0026#34;关羽\u0026#34;,22,\u0026#34;男\u0026#34;}, {\u0026#34;张飞\u0026#34;,20,\u0026#34;男\u0026#34;}, {\u0026#34;赵云\u0026#34;,21,\u0026#34;男\u0026#34;}, {\u0026#34;貂蝉\u0026#34;,19,\u0026#34;女\u0026#34;}, 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //英雄结构体 struct hero { string name; int age; string sex; }; //冒泡排序 void bubbleSort(hero arr[] , int len) { for (int i = 0; i \u0026lt; len - 1; i++) { for (int j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j].age \u0026gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组 void printHeros(hero arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; \u0026#34; 性别： \u0026#34; \u0026lt;\u0026lt; arr[i].sex \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } } int main() { struct hero arr[5] = { {\u0026#34;刘备\u0026#34;,23,\u0026#34;男\u0026#34;}, {\u0026#34;关羽\u0026#34;,22,\u0026#34;男\u0026#34;}, {\u0026#34;张飞\u0026#34;,20,\u0026#34;男\u0026#34;}, {\u0026#34;赵云\u0026#34;,21,\u0026#34;男\u0026#34;}, {\u0026#34;貂蝉\u0026#34;,19,\u0026#34;女\u0026#34;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2023-06-01T00:00:00Z","image":"https://www.happylee.cn/post/cpp-base/CPP-COVER.png","permalink":"https://www.happylee.cn/post/cpp-base/","title":"C++基础入门"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档\n本部分的实验报告适用于电子信息工程专业，其他专业仅供参考\n本实验中的程序运行环境为Matlab 2016a，不同版本下的程序可能有所差异\n严禁直接抄袭本报告、复制粘贴改名等学术不端行为\n目录： 实验三 连续时间LTI系统的频域分析 实验四 连续时间LTI系统的复频域分析 《信号与系统》实验小结 （实验报告中的程序代码，可点击这里查看）\n实验报告： Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档\n严禁直接抄袭本报告、复制粘贴改名等学术不端行为！\n","date":"2023-05-29T00:00:00Z","image":"https://www.happylee.cn/post/signal-system-3-4/matlab_img.png","permalink":"https://www.happylee.cn/post/signal-system-3-4/","title":"信号与系统实验报告3-4"},{"content":" 温馨提示：\n1.实验步骤2中表格的测量值应近似于理论值。若误差太大，排除接线问题后，应考虑为元器件(uA741)烧毁\n2.实验报告要求2中的图像，纵坐标轴需要反向（具体根据实验老师的要求和提示）\n数电实验5 D/A转换器及其应用 一、实验表格（理论值） 二、实验图像 三、实验报告要求（问题回答） D/A转换器有哪几种类型？\n权电阻网络D/A转换器 倒T形电阻网络D/A转换器 权电流型D/A转换器 电阻串联分压式D/A转换器 画出步骤 (3) 观测到的波形\n即本文第二部分“实验图像”所示，纵坐标轴需要反向（具体根据实验老师的要求和提示）\n","date":"2023-05-22T00:00:00Z","permalink":"https://www.happylee.cn/post/signal-electric-5/","title":"数电实验5：D/A转换器及其应用"},{"content":" 温馨提示：\n1.本次实验需要完成示波器的3个图像，见第二部分“实验图片”\n2.实验报告中需要作图的部分，见第一部分的第2节“实验步骤及内容”\n数电实验4 集成定时器555的原理及其应用 一、实验报告要求 1.问题回答 2.实验步骤及内容 二、实验图片 单稳态触发器 脉冲宽度 Tw=56ms 多谐振荡器 周期 T=180ms 施密特触发器 回差电压 ΔU=1.76V ","date":"2023-05-21T00:00:00Z","permalink":"https://www.happylee.cn/post/signal-electric-4/","title":"数电实验4：集成定时器555的原理及其应用"},{"content":" 注意：\n请使用电脑端访问此页面，手机端暂时无法正常显示PDF文档 本部分的实验报告适用于电子信息工程专业，其他专业仅供参考 本实验中的程序运行环境为Matlab 2016a，不同版本下的程序可能有所差异 严禁直接抄袭本报告、复制粘贴改名等学术不端行为 目录： 实验预习思考题 实验一 连续时间信号的表示、连续时间LTI系统的时域分析 实验二 周期信号的傅里叶级数分析 （实验报告中的程序代码，可点击这里查看）\n实验报告： Unable to display PDF file. Download instead.\n请使用电脑端访问此页面，手机端可能无法正常显示上方PDF文档\n严禁直接抄袭本报告、复制粘贴改名等学术不端行为！\n","date":"2023-05-21T00:00:00Z","image":"https://www.happylee.cn/post/signal-system-1-2/matlab_img.png","permalink":"https://www.happylee.cn/post/signal-system-1-2/","title":"信号与系统实验报告1-2"},{"content":" 温馨提示：如需实验图片和实验报告表格数据，见本文的第二部分和第三部分\n特别感谢：本次实验报告中第二个问题的最终答案，是与小陈同学交流讨论得到的\n数电实验3 集成计数器及其应用 一、实验报告要求 二、实验图片 1.译码器CD4511逻辑功能的验证（译码、锁存、消隐、灯测试等）：\n2.计数器74LS162逻辑功能的验证计数、清除、预置、使能及进位等）：\n三、实验内容及步骤 ","date":"2023-05-04T00:00:00Z","permalink":"https://www.happylee.cn/post/signal-electric-3/","title":"数电实验3：集成计数器及其应用"},{"content":"NOW 由于本网站中所显示的图片，采用的是基于vika所搭建的图床。受vika平台的影响，网站中的嵌入图片无法正常加载和显示。目前已经定位该问题，正在全力进行修复。\n对于本网站中目前出现的图片显示问题，我决定放弃原来的vika图床，采用新的图床解决方案。\n另外，对于同学们有较大需求的“实验与仿真”板块中的图片，我已经临时整理备份，点击这里访问。\n除此之外，在本次网站维护中，我还将给网站进行一些页面优化，并会给网站添加和使用自定义域名。同时，我将废弃目前部署到Gitee上的方案，重新部署到GitHub上，并使用CDN加速，确保网站访问的稳定性。\nOTHER 本次网站的维护和更新预计将持续五天左右，这期间给您带来的不便，我在此深表歉意！ ","date":"2023-04-25T00:00:00Z","image":"https://www.happylee.cn/post/2023.4.25%E7%B4%A7%E6%80%A5%E9%80%9A%E7%9F%A5/notic.png","permalink":"https://www.happylee.cn/post/2023.4.25%E7%B4%A7%E6%80%A5%E9%80%9A%E7%9F%A5/","title":"2023.4.25紧急通知"},{"content":" 温馨提示：需要参考“实验报告要求”处理的，请直接跳转到本文的第三部分即可\n数电实验2 触发器及其应用 一、实验内容及步骤： 二、实验步骤5的说明： 1.理论分析 2.仿真验证 **注意：**上图中001，即数码管显示为“1”这种情况，漏截图了\n​\t具体的仿真操作，可以参考这篇文章：Multisim实现D触发器模拟异步计数器\n三、实验报告要求： 问题1：说明如何设定JK触发器和D触发器的初始状态 答：\n通过设置触发器的置1端（SD）和置0端（RD），本次实验中均为低电平有效，来设定触发器的初始状态，完成后保持高电平(逻辑开关打到1)。\n具体操作为：先将RD,SD接逻辑开关，开关打到1；\n若要Qn=0，则RD逻辑开关打到0再打到1；\n若要Qn=1，则SD逻辑开关打到0再打到1。\n问题2：根据表2.2.7测得的数据，分析出该时序电路的逻辑功能。 答：\n3位异步二进制递增计数器（模8递增计数器）。\n","date":"2023-04-22T00:00:00Z","permalink":"https://www.happylee.cn/post/signal-electric-2/","title":"数电实验2：触发器及其应用"},{"content":" 写在前面：\n当你准备学习单片机知识时，欢迎你开始步入神奇的电子技术世界！\n本系列文章是我学习单片机开发的路线笔记，并将会持续不定期更新\n如果你在阅读文章中有任何不懂的问题，或者发现文章中一些错误的地方\n欢迎在下方评论区，与我联系和讨论！\n前言： 在正式开始了解和接触单片机之前，你最好应具备：\n学习过C语言，掌握C语言中的一些基本语法，有一定的编程基础\n学习过模电和数电，或者有一定的相关了解和基础（尤其是数电）\n如果你没有学过模电和数电，也没有关系\n这里推荐一个科普课程：计算机科学速成课（只需要看前10节就行，每节时长只有10分钟左右）\n看完之后，将会对后续单片机的学习有更好的促进作用！\n正文： 一、单片机介绍 •单片机，英文Micro Controller Unit，简称MCU\n•内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能\n•单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制\n•单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用\n•同时，学习使用单片机是了解计算机原理与结构的最佳选择\n二、什么是51单片机/为什么叫51单片机？ 51单片机是对兼容英特尔8051指令系统的单片机的统称。正是因为这个“8051”有个51,所以凡是与“8051”内核一样的单片机都统称为51系列单片机。 51单片机广泛应用于家用电器、汽车、工业测控、通信设备中。因为51单片机的指令系统、内部结构相对简单，所以国内许多高校用其进行单片机入门教学。 三、开发工具 开发软件Keil5C51——用于编写单片机程序\n烧录软件stc-isp——用于将写好的程序下载到单片机上\n普中51单片机开发板\n​\t上面除了有STC89C51芯片(即51单片机)以外，另外在开发板上还集成有数码管、LED灯管、蜂鸣器等模块，方便我们学习单片机时，来调用和实现一些功能。\n四、推荐教程视频 B站：江协科技 51单片机入门教程-2020版 程序全程纯手打 从零开始入门（原江科大自化协51单片机教程视频） 五、后续更新 我会不定期更新自己在学习51单片机过程中的学习笔记和心得体会，并上传相关的实验操作代码和数据。\n欢迎感兴趣的同学，与我交流学习，我们共同进步！\n本系列文章未完待续，请关注留意！\n","date":"2023-04-15T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/post/stc51.png","permalink":"https://www.happylee.cn/post/51-mcu/","title":"51单片机入门"},{"content":"数电实验1 集成逻辑门电路 ","date":"2023-04-10T00:00:00Z","permalink":"https://www.happylee.cn/post/signal-electric-1/","title":"数电实验1：集成逻辑门电路"},{"content":"前言 问题描述：\n当我们拥有多个git账号的时候，比如一个是GitHub账号，用于自己进行一些开发活动；后来觉得GitHub访问起来太慢了，又注册了国内的码云gitee账号(或者来了一个gitlab账号，一般是公司内部用到的git)。我们在使用这几者时，就必然会涉及到一个问题：在绑定SSH密钥的过程中，生成第二个git的key的时候会覆盖第一个的key，导致必然其中有一个就用不了。 解决方案：\n多个ssh key管理：我们可以在.ssh文件目录下新建一个config文件配置一下，就可以解决问题 正文 一、原因分析： 注意：出现SSH密钥冲突问题的实质，其实就在于我们每次（尤其是第一次时）是否知道可以自定义密钥名\n很多人第一次生成密钥时，直接在命令行中：\n1 2 3 git config --global user.name \u0026#34;用户名\u0026#34; git config --global user.email \u0026#34;用户邮箱\u0026#34; ssh-keygen -t rsa -C \u0026#34;用户邮箱\u0026#34; 前两行是在设置用户名和邮箱，重点是上面第三行代码，即生成密钥的代码。如果就按这样写的话，那么密钥的文件名字就是默认的：\n那么我们在第二个平台进行生成密钥（比如我们已经生成过GitHub的ssh密钥，再准备生成gitee的密钥时）：\n图中 Overwrite(y/n)? 即在提示是否覆盖：选择y，就会覆盖导致之前的失效；选择n，即取消本次的覆盖，就不会创建新的密钥了\n二、解决方案： 1.查看ssh文件 在桌面 点击鼠标右键 （Git Bash here） 进入 .ssh 文件夹 如下图（注意空格）：\nls 命令检查是否存在 SSH Key\n出现上图说明我们之前的确已经生成过SSH密钥了\n注意：如果没有该文件夹，自己 C 盘的 用户路径下 新建 .ssh 文件夹\n2.删除之前的.ssh 3.分别生成gitee和github 的 SSH Key （1）生成github的密钥，自定义其名称\n1 ssh-keygen -t rsa -C \u0026#34;xxxxxxx@qq.com\u0026#34; -f \u0026#34;id_rsa_github\u0026#34; （2）配置github的SSH key\n输入自己的邮箱后一直回车，即可出现以下画面\n（3）查看SSH Key\n1 cat id_rsa_github.pub // 这里是查看 github的 SSH Key 出现下图：\n（4）拷贝 ssh-rsa 开头的 ssh key，然后到github上添加ssh key\n（5）配置gitee的 ssh key\n操作和上面的类似，只是把命令换成了\n1 2 ssh-keygen -t rsa -C \u0026#34;xxxxxxx@qq.com\u0026#34; -f \u0026#34;id_rsa_gitee\u0026#34; //生成gitee的SSH Key cat id_rsa_gitee.pub //这里是查看gitee的SSHKey（这里注意和github区分一下) （6）然后把生成的 ssh key 复制到 gitee，进行添加 ssh key 操作，（操作类似上面的 github 添加 ssh） 4.添加 config解决ssh冲突 在 .ssh 文件夹路径下 ，执行命令：vi config 在这里面一个一个输入比较慢，所以先退出，先按键盘的 Esc，输入“ :wq ”，回车退出然后 C盘 的.shh 文件夹中 找到 并打开 config 文件，将下面的内容复制进 config 文件，保存即可\n1 2 3 4 5 6 7 8 9 10 11 # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 注意：上面这个是关键的一步，一定要新创建config文件来解决SSH冲突\n5.测试 执行ssh -T git@github.com,出现successfully,则github配置成功。 执行ssh -T git@gitee.com,出现successfully,则gitee配置成功。 注意： 可能会出现下面的内容 （直接输入 yes 即可最终出现successfully，配置成功）\nThe authenticity of host \u0026lsquo;gitee.com (212.64.63.190)\u0026rsquo; can\u0026rsquo;t be established. ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc. Are you sure you want to continue connecting (yes/no/[fingerprint])\n","date":"2023-04-05T00:00:00Z","permalink":"https://www.happylee.cn/post/%E8%A7%A3%E5%86%B3git%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8Cgitee%E6%97%B6%E5%AF%86%E9%92%A5ssh%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","title":"解决Git同时部署到GitHub和Gitee时，密钥SSH冲突问题"},{"content":" 注意：本篇文章中PicGo+Vika搭建图床的方案目前暂时失效，详情可以查看我置顶的网站更新公告文章。\n​\t现在，我已经采用PicGo+GitHub搭建图床的方案，具体的也可以参考更新公告中的内容。\n原理： 利用PicGo+Vika // PicGo+GitHub实现个人图床的搭建\n注意：\nPicGo在安装前，需要先安装node.js环境（可在本网站“资源”板块获取）； 下面关于PicGo的下载地址有两个，第二个为GitHub上的，受网络影响可能无法正常打开，推荐在第一个链接访问并下载； PicGo的不同版本，可能兼容性和效果不同，博主安装的是V2.3.1版本 PicGo官方下载地址：\nhttp://cpasion-docs.gitee.io/picgo-doc/ （Gitee平台，推荐） https://github.com/Molunerfinn/PicGo （GitHub） vika官网：\nhttps://vika.cn/ GitHub官网：\nhttps://github.com/ 操作： 这里，我推荐一个B站UP主佳豪君z的视频：\n最后： 受vika平台后续运营和更新影响，此种搭建图床的方法有可能会失效，不一定仍然适用，具体还请结合实际情况而定！\n","date":"2023-04-02T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/cover/default.jpg","permalink":"https://www.happylee.cn/post/%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","title":"搭建免费的个人图床"},{"content":"实验8 三相交流电路的研究 ","date":"2023-03-28T00:00:00Z","permalink":"https://www.happylee.cn/post/electric-8/","title":"电路分析基础 实验八"},{"content":"实验7 RL串联电路及功率因素提高的研究 ","date":"2023-03-20T00:00:00Z","permalink":"https://www.happylee.cn/post/electric-7/","title":"电路分析基础 实验七"},{"content":"前言 欢迎阅读本篇教程！首先说明一点，本教程将适用于所有零基础的电脑小白。因此，在实际操作之前不必感到紧张。同时，由于一小部分操作需要调用命令行，那么遇到命令行或者终端上的报错，也是很正常的。这时不必害怕，放松心态，大不了把前面的命令重输一遍即可。如果还是无法解决，那就复制命令行中的错误提示，在万能的浏览器中搜索即可。总而言之，好事多磨，办法总比困难多！\n这里我推荐一个B站Up主 火车啦啦 的教学视频：你可以根据需要，先总的看一下视频做一个初步了解，然后再对照正文里的步骤进行详细操作。\n正文 一、准备工作 （1）必要软件安装（点击名称即可跳转到各自官网）：\nnode.js：用于安装后面的博客框架\nGit：用于后面将网站部署到Gitee或者GitHub上\n（2）可选软件（以下软件只是用于后面配置文件更改以及博客写作，可根据需要安装）：\nVisual Studio Code：用来打开网站文件中的配置文件\nTypora：方便写博客文章\n温馨提示：上述软件均为国外软件，可能受网络影响，无法打开其官方网站。我已经将其安装包，上传至网盘，可根据个人需要，点击本博客网站上面的“资源”板块寻找和下载。最后重申一下，尽量还是自己想办法获取到官方最新版。\n二、检查工作 我们怎么去查看上面的软件是否安装成功了呢？\n检验是否成功安装 用 Win + R 打开运行，输入 cmd ，点击确定：\n进入cmd控制台：\n依次输入下面的指令并回车：（注意输入空格） node.js 的检查 1 node -v npm的检查 NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题\n1 npm -v Git 的检查 1 git --version 以上有显示版本号，则说明安装成功\n除此之外，我们也需要简单配置一下node.js，可以点击下方链接，只需要阅读文章“Step4：环境配置”部分，进行操作：\nnode.js安装及环境配置超详细教程【Windows系统安装包方式】：\nhttps://blog.csdn.net/weixin_44893902/article/details/121788104\n三、博客框架——Hexo的安装 注意（在下面的方式1和2中任选一个即可）：\n方式1.你可以依然用 Win + R 打开运行，输入 cmd 并进入cmd窗口进行操作（这时，你操作完后面步骤后所生成的myblog文件夹会出现在默认位置，一般是C盘下的用户文件中，例如我的是C:\\Users\\Lee\u0026gt;）\n方式2.如果你想把博客文件创建在其他盘，比如D盘，那么只需要在D盘根目录下或者D盘的一个文件夹中打开cmd后，再进行下面的操作即可。可参考这篇文章：https://blog.csdn.net/weixin_44679832/article/details/123942274\n下面操作均在cmd中输入指令完成：\n0.（可选项）推荐安装之前可以先设置一下淘宝镜像加速器 1 npm install -g cnpm --registry=https://registry.npm.taobao.org 1.全局安装框架 1 npm install hexo-cli -g 2.创建你的博客目录 1 hexo init 你博客的文件夹名字 (比如：hexo init myblog) 3.进入你的博客文件 1 cd 你博客的文件夹名字 (比如：cd myblog) 4.复制文件到你博客的目录 1 npm install 5.安装Hexo部署插件 （此步骤用于安装本地部署插件，如果遗漏会造成后面 hexo deploy出错）\n1 npm install hexo-deployer-git --save 四、注册Gitee（推荐）或者GitHub账号 点击下面网站名称，即可跳转到对应官网\nGitee（码云）：简单地说，这是一个国内的代码托管网站，而我们将本地的博客网页文件部署上传到Gitee后，此时Gitee就相当于服务器的功能，继而就可以实现把博客网站发送到网络上，让别人也可以访问。\nGitHub：简单的说，你可以理解为国外的代码托管网站，由于网络波动或者限制，本次搭建博客并不推荐。但是对于想在技术上继续研究和学习的同学来讲，强烈建议了解和入手！\n可以观看下面视频对应部分进行操作： 使用Gitee的小伙伴（重点观看注册和pages服务部分）： 【使用Hexo和码云Gitee免费搭建个人博客保姆级建站教程】 https://www.bilibili.com/video/BV1Np4y1i7r5/?share_source=copy_web\u0026vd_source=d67e16cc6c93f4efcf3a7a037720b2af\n使用GitHub的小伙伴（只需要看前面部分）： 【hexo搭建个人博客超简单效果超好的个人网站博客搭建对小白很友好】 https://www.bilibili.com/video/BV1Rt4y1k7it/?p=2\u0026share_source=copy_web\u0026vd_source=d67e16cc6c93f4efcf3a7a037720b2af\n你需要完成好以下工作： 1.注册账号\n2.创建仓库并设置（视频里有注意事项）\n3.实名认证，打开Git Pages服务（使用Gitee的需要）\n五、Git的配置 用 Win + R 打开运行，输入 cmd 并进入cmd\n设置用户名称 1 git config --global user.name \u0026#34;用户名\u0026#34; 设置用户邮箱 1 git config --global user.email \u0026#34;用户邮箱\u0026#34; 生成密钥 1 ssh-keygen -t rsa -C \u0026#34;用户邮箱\u0026#34; 以上代码执行之后，会让你设置密码，推荐一个都不要设置，直接连按三次回车键。\n然后，按照视频中的步骤，将本地生成的ssh密钥填写到gitee或者github平台上对应的位置。\n六、博客 _config.yml 文件的配置 打开你博客根目录的 _config.yml 文件，将一下信息添加到里面去。\n1 2 3 4 deploy: type: git repo: https://gitee.com/xxxx/xxxx.git #替换成你自己仓库的HTTP URL地址 branch: master 【注意区分】你博客根目录的 _config.yml 文件，和主题根目录的 _config.yml 文件！\n七、生成博客网页，并部署到Gitee上 在你的博客文件的根目录下打开cmd控制台\n1、清理缓存 1 hexo cl hexo cl 是 hexo clean 的简写\n2、生成静态页面 1 hexo g hexo g 是 hexo generate 的简写\n3、在本地映射（预览） 1 hexo s hexo s 是 hexo server 的简写\n可以在浏览器中访问此时命令行中出现的链接，即可预览生成的博客页面：\n4、部署推送 上面生成的博客页面确认无误后，在命令行中按CTRL+C结束本地预览，接着可执行下一步\n第一次部署推送过程中，会弹出Gitee登陆提示，填写好你的账号和密码即可\n（如果你采用的是github部署，最好先挂上一个加速器，再执行下面的部署命令。如此，就可以稳定地在浏览器中，选择登陆和验证你的github账号）\n1 hexo d hexo d 是 hexo deploy 的简写\n部署成功如下图所示：\n此时，你当初为博客创建的Gitee仓库中就会更新\n按照视频的教程，启用Gitee Pages服务，完成配置和更新，继而就可以通过Gitee为你分配的链接访问你的博客了\n至此，恭喜你，我们的博客网站基本搭建完毕了！\n5、温馨提示 以上连写：示例一（清理缓存 + 生成静态页面 + 在本地预览）\n1 hexo cl \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo s 以上连写：示例二（清理缓存 + 生成静态页面 + 部署推送）\n1 hexo cl \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo d 八、（进阶）自定义博客主题推荐与配置 主题一：Butterfly 这里我推荐一下我所使用的主题：Butterfly - A Simple and Card UI Design theme for Hexo（点击即可访问）\n你可以滑动一下主页后，在右下角出现的齿轮按钮中，调整成简体中文模式\n然后再仔细阅读其网页中”文档“板块，进行设置，DIY出属于你的独一无二博客网站啦！\n主题示例： 主题二：Matery 参考网站：https://www.lixl.cn/2019/092856736.html\n主题示例： ","date":"2023-03-16T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/HappyLeeCode/IMG/cover/hexo.png","permalink":"https://www.happylee.cn/post/blog-hexo/","title":"入门搭建个人博客教程（Hexo篇）"}]